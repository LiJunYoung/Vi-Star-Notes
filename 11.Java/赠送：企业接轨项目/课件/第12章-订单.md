# 第12章-订单

## 第12章-购物车结算-订单提交

**学习目标：**

-   能够描述购物车结算及后续订单提交业务
-   完成用户下单功能
-   完成订单列表功能

# 1、 业务介绍

![](image/wps3_i9AHJQTi8R.png)

订单业务在整个电商平台中处于核心位置，也是比较复杂的一块业务。是把“物”变为“钱”的一个中转站。

整个订单模块一共分四部分组成：

1.  结算
2.  下单
3.  对接支付服务
4.  对接库存管理系统

# 2、结算页

订单结算页数据展示来源图

![](image/image__6soL4UKCI.png)

入口：购物车点击计算按钮 ，结算必须要登录！

![](image/wps5_69YQmNgPJ7.jpg)

![](image/wps6_PpnCab0mBK.jpg)

分析页面需要的数据：

1、 需要用户地址信息

2、 购物车中选择的商品列表

3、 用户地址信息在service-user模块，购物车信息在service-cart模块，所以我们要在相应模块提供api接口，通过feign client调用获取数据

## 2.1 在 service-user模块获取地址列表

> YAPI接口地址：[http://192.168.200.128:3000/project/11/interface/api/827](http://192.168.200.128:3000/project/11/interface/api/827 "http://192.168.200.128:3000/project/11/interface/api/827")

### 2.1.3 编写控制器

```java
package com.atguigu.gmall.user.controller;

import com.atguigu.gmall.common.result.Result;
import com.atguigu.gmall.user.model.UserAddress;
import com.atguigu.gmall.user.service.UserAddressService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * @author: atguigu
 * @create: 2023-01-12 09:27
 */
@RestController
@RequestMapping("/api/user/")
public class UserApiContrller {


    @Autowired
    private UserAddressService userAddressService;


    //  注入服务层
    @Autowired
    private UserAddressService userAddressService;
    
    //  移动端获取收货地址列表.
    //  http://localhost/api/user/userAddress/auth/findUserAddressList
    @GetMapping("userAddress/auth/findUserAddressList")
    public Result findUserAddressList(HttpServletRequest request){
        String userId = AuthContextHolder.getUserId(request);
        //  需要获取到收货地址列表.
        //  调用服务层方法
        List<UserAddress> userAddressList = userAddressService.getUserAddressListByUserId(userId);
        return Result.ok(userAddressList);
    }
}
```

### 2.1.2 编写接口与实现类

```java
package com.atguigu.gmall.user.service;

import com.atguigu.gmall.user.model.UserAddress;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;

/**
 * 用户地址表 业务接口类
 * @author atguigu
 * @since 2023-01-10
 */
public interface UserAddressService extends IService<UserAddress> {

      /**
     * 根据userId 来获取收货地址列表
     * @param userId
     * @return
     */
    List<UserAddress> getUserAddressListByUserId(String userId);
}

```

```java
package com.atguigu.gmall.user.service.impl;

import com.atguigu.gmall.user.model.UserAddress;
import com.atguigu.gmall.user.mapper.UserAddressMapper;
import com.atguigu.gmall.user.service.UserAddressService;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 用户地址表 业务实现类
 *
 * @author atguigu
 * @since 2023-01-10
 */
@Service
public class UserAddressServiceImpl extends ServiceImpl<UserAddressMapper, UserAddress> implements UserAddressService {
    /**
     * 根据用户ID查询用户收件地址薄列表
     *
     * @param userId
     * @return
     */
    @Override
    public List<UserAddress> getUserAddressListByUserId(String userId) {
        //  select * from user_address where user_id = ?;
        LambdaQueryWrapper<UserAddress> userAddressLambdaQueryWrapper = new LambdaQueryWrapper<>();
        userAddressLambdaQueryWrapper.eq(UserAddress::getUserId,userId);
        return userAddressMapper.selectList(userAddressLambdaQueryWrapper);
    }
}
```

### 2.1.1 添加mapper

```java
package com.atguigu.gmall.user.mapper;

import com.atguigu.gmall.user.model.UserAddress;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

public interface UserAddressMapper extends BaseMapper<UserAddress> {
}
```

### 2.1.3 提供Feign接口

1.  选中`gmall-client`模块新建子模块：service-user-client 送货地址列表异步ajax方式获取。这个模块也可以暂时不写！

    ![](image/image-20221207235537204_qN2dU9ph2W.png)
2.  提供远程调用的API  Feign接口
    ```java
    package com.atguigu.gmall.user.client;

    import com.atguigu.gmall.user.client.impl.UserDegradeFeignClient;
    import com.atguigu.gmall.user.model.UserAddress;
    import org.springframework.cloud.openfeign.FeignClient;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PathVariable;

    import java.util.List;

    @FeignClient(value = "service-user", fallback = UserDegradeFeignClient.class)
    public interface UserFeignClient {

        
    }
    ```
3.  服务降级类
    ```java
    package com.atguigu.gmall.user.client.impl;


    import com.atguigu.gmall.user.model.UserAddress;
    import com.atguigu.gmall.user.client.UserFeignClient;
    import org.springframework.stereotype.Component;

    import java.util.List;

    @Component
    public class UserDegradeFeignClient implements UserFeignClient {

      
    }
    ```

## 2.2 在service-cart模块获取选中商品数据

> YAPI接口地址：[http://192.168.200.128:3000/project/11/interface/api/691](http://192.168.200.128:3000/project/11/interface/api/691 "http://192.168.200.128:3000/project/11/interface/api/691")

1.  CartApiController中处理获取指定用户选中购物车列表数据
    ```java
    /**
     * 查询用户购物车中已勾选的商品列表
     * @param userId
     * @return
     */
    @GetMapping("/getCartCheckedList/{userId}")
    public List<CartInfo> getCartCheckedList(@PathVariable("userId") Long userId){
        List<CartInfo> list = cartService.getCartCheckedList(userId);
        return list;
    }
    ```
2.  CartService业务层接口
    ```java
    /**
     * 查询用户购物车中已勾选的商品列表
     * @param userId
     * @return
     */
    List<CartInfo> getCartCheckedList(Long userId);
    ```
3.  CartServiceImpl业务层实现类
    ```java
    /**
     * 查询用户已选中购物车商品列表
     * @param userId
     * @return
     */
    @Override
    public List<CartInfo> getCartCheckedList(Long userId) {
        //1.构建查询购物车Hash结构的Key
        String cartKey = getCartKey(userId.toString());
        //2.查询用户所有的购物车商品
        BoundHashOperations<String, String, CartInfo> hashOps = redisTemplate.boundHashOps(cartKey);
        List<CartInfo> cartInfoList = hashOps.values();
        //3.过滤商品为选中的
        if(!CollectionUtils.isEmpty(cartInfoList)){
            List<CartInfo> cartCheckedList = cartInfoList.stream().filter(cartInfo -> {
                //过滤条件 购物车对象中 isChecked 为1 符合条件
                return cartInfo.getIsChecked() == 1;
            }).collect(Collectors.toList());
            return cartCheckedList;
        }
        return null;
    }
    ```
4.  在`service-cart-client`模块中提供Feign API接口
    ```java
    package com.atguigu.gmall.cart.feign;

    import com.atguigu.gmall.cart.feign.impl.CartDegradeFeignClient;
    import com.atguigu.gmall.cart.model.CartInfo;
    import org.springframework.cloud.openfeign.FeignClient;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PathVariable;

    import java.util.List;

    @FeignClient(value = "service-cart", fallback = CartDegradeFeignClient.class)
    public interface CartFeignClient  {

        /**
         * 查询用户购物车中已勾选的商品列表
         * @param userId
         * @return
         */
        @GetMapping("/api/cart/getCartCheckedList/{userId}")
        public List<CartInfo> getCartCheckedList(@PathVariable("userId") Long userId);

    }
    ```
5.  服务降级类
    ```java
    package com.atguigu.gmall.cart.feign.impl;

    import com.atguigu.gmall.cart.feign.CartFeignClient;
    import com.atguigu.gmall.cart.model.CartInfo;
    import org.springframework.stereotype.Component;

    import java.util.List;

    /**
     * author:atguigu
     * date:2022/11/23 9:35
     * 描述：
     **/
    @Component
    public class CartDegradeFeignClient implements CartFeignClient {
        @Override
        public List<CartInfo> getCartCheckedList(Long userId) {
            return null;
        }
    }
    ```

## 2.3 搭建service-order模块

### 2.3.1 搭建service-order

在`gmall-service`下创建子模块：service-order

![](image/image-20221208001711920_t1OkjuAvi8.png)

### 2.3.2 修改pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>gmall-service</artifactId>
        <groupId>com.atguigu.gmall</groupId>
        <version>1.0</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>service-order</artifactId>

    <dependencies>
        <dependency>
            <groupId>com.atguigu.gmall</groupId>
            <artifactId>service-product-client</artifactId>
            <version>1.0</version>
        </dependency>
        <dependency>
            <groupId>com.atguigu.gmall</groupId>
            <artifactId>service-cart-client</artifactId>
            <version>1.0</version>
        </dependency>
    </dependencies>

    <build>
        <finalName>service-order</finalName>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

### 2.2.3 启动类

```java
package com.atguigu.gmall;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
public class OrderApp {
    public static void main(String[] args) {
        SpringApplication.run(OrderApp.class, args);
    }
}
```

### 2.3.4 配置文件

在`service-order`模块resources目录下创建：bootstrap.properties

```.properties
spring.application.name=service-order
spring.profiles.active=dev
spring.cloud.nacos.discovery.server-addr=192.168.200.128:8848
spring.cloud.nacos.config.server-addr=192.168.200.128:8848
spring.cloud.nacos.config.prefix=${spring.application.name}
spring.cloud.nacos.config.file-extension=yaml
spring.cloud.nacos.config.shared-configs[0].data-id=common.yaml

```

### 2.3.5 订单的数据结构

order\_info ：订单表

order\_detail：订单明细

![](image/wps7_AojlbOICPT.jpg)

| id                | 主键。自动生成                    |
| ----------------- | -------------------------- |
| consignee         | 收货人名称。页面获取                 |
| consignee\_tel    | 收货人电话。页面获取                 |
| deliveryAddress   | 收货地址。页面获取                  |
| total\_amount     | 总金额。计算                     |
| order\_status     | 订单状态，用于显示给用户查看。设定初始值。      |
| userId            | 用户Id。网关过滤器已放到请求头中。         |
| payment\_way      | 支付方式（网上支付、货到付款）。页面获取       |
| orderComment      | 订单状态。页面获取                  |
| out\_trade\_no    | 第三方支付编号。按规则生成              |
| create\_time      | 创建时间。设当前时间                 |
| expire\_time      | 默认当前时间+1天                  |
| process\_status   | 订单进度状态，程序控制、 后台管理查看。设定初始值， |
| tracking\_no      | 物流编号,初始为空，发货后补充            |
| parent\_order\_id | 拆单时产生，默认为空                 |

| id           | 主键，自动生成          |
| ------------ | ---------------- |
| order\_id    | 订单编号，主表保存后给从表    |
| sku\_id      | 商品id 页面传递        |
| sku\_name    | 商品名称，后台添加        |
| img\_url     | 图片路径，后台添加        |
| order\_price | 商品单价，从页面中获取，并验价。 |
| sku\_num     | 商品个数，从页面中获取      |

订单实体类

```java
package com.atguigu.gmall.model.order;


@Data
@ApiModel(description = "订单信息")
@TableName("order_info")
public class OrderInfo extends BaseEntity {
   
   private static final long serialVersionUID = 1L;
   
   @ApiModelProperty(value = "收货人")
   @TableField("consignee")
   private String consignee;

   @ApiModelProperty(value = "收件人电话")
   @TableField("consignee_tel")
   private String consigneeTel;

   @ApiModelProperty(value = "总金额")
   @TableField("total_amount")
   private BigDecimal totalAmount;

   @ApiModelProperty(value = "订单状态")
   @TableField("order_status")
   private String orderStatus;

   @ApiModelProperty(value = "用户id")
   @TableField("user_id")
   private Long userId;

   @ApiModelProperty(value = "付款方式")
   @TableField("payment_way")
   private String paymentWay;

   @ApiModelProperty(value = "送货地址")
   @TableField("delivery_address")
   private String deliveryAddress;

   @ApiModelProperty(value = "订单备注")
   @TableField("order_comment")
   private String orderComment;

   @ApiModelProperty(value = "订单交易编号（第三方支付用)")
   @TableField("out_trade_no")
   private String outTradeNo;

   @ApiModelProperty(value = "订单描述(第三方支付用)")
   @TableField("trade_body")
   private String tradeBody;

   @ApiModelProperty(value = "创建时间")
   @TableField("create_time")
@JsonFormat(locale="zh", timezone="GMT+8", pattern="yyyy-MM-dd HH:mm:ss")

   private Date createTime;

   @ApiModelProperty(value = "失效时间")
   @TableField("expire_time")
@JsonFormat(locale="zh", timezone="GMT+8", pattern="yyyy-MM-dd HH:mm:ss")

   private Date expireTime;

   @ApiModelProperty(value = "进度状态")
   @TableField("process_status")
   private String processStatus;

   @ApiModelProperty(value = "物流单编号")
   @TableField("tracking_no")
   private String trackingNo;

   @ApiModelProperty(value = "父订单编号")
   @TableField("parent_order_id")
   private Long parentOrderId;

   @ApiModelProperty(value = "图片路径")
   @TableField("img_url")
   private String imgUrl;

   @TableField(exist = false)
   private List<OrderDetail> orderDetailList;

   @TableField(exist = false)
   private String wareId;

   // 计算总价格
   public void sumTotalAmount(){
      BigDecimal totalAmount=new BigDecimal("0");
      for (OrderDetail orderDetail : orderDetailList) {
         totalAmount= totalAmount.add(orderDetail.getOrderPrice().multiply(new BigDecimal(orderDetail.getSkuNum())));
      }
      this.totalAmount=  totalAmount;
   }

}
```

订单详情实体类

```java
package com.atguigu.gmall.model.order;

@Data
@ApiModel(description = "订单明细")
@TableName("order_detail")
public class OrderDetail extends BaseEntity {
   
   private static final long serialVersionUID = 1L;
   
   @ApiModelProperty(value = "订单编号")
   @TableField("order_id")
   private Long orderId;

   @ApiModelProperty(value = "sku_id")
   @TableField("sku_id")
   private Long skuId;

   @ApiModelProperty(value = "sku名称（冗余)")
   @TableField("sku_name")
   private String skuName;

   @ApiModelProperty(value = "图片名称（冗余)")
   @TableField("img_url")
   private String imgUrl;

   @ApiModelProperty(value = "购买价格(下单时sku价格）")
   @TableField("order_price")
   private BigDecimal orderPrice;

   @ApiModelProperty(value = "购买个数")
   @TableField("sku_num")
   private Integer skuNum;

   // 是否有足够的库存！
   @TableField(exist = false)
   private String hasStock;

}
```

**注意**：其中hasStock是一个非持久化属性，用与传递【是否还有库存】的标志。如果商品在库存中有足够数据，suceess = "1"，fail="0"

### 2.3.5 接口封装OrderApiController

> YAPI接口地址：[http://192.168.200.128:3000/project/11/interface/api/755](http://192.168.200.128:3000/project/11/interface/api/755 "http://192.168.200.128:3000/project/11/interface/api/755")

1.  为了在确定订单的页面展示收货地址，所以在`service-order`模块的pom.xml添加依赖-已添加
    ```java
    <dependency>
        <groupId>com.atguigu.gmall</groupId>
        <artifactId>service-user-client</artifactId>
        <version>1.0</version>
    </dependency>
    ```
2.  在`service-order`模块中处理订单确认页面请求
    ```java
    package com.atguigu.gmall.order.controller;

    import com.atguigu.gmall.common.result.Result;
    import com.atguigu.gmall.common.util.AuthContextHolder;
    import com.atguigu.gmall.order.service.OrderInfoService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;

    import javax.servlet.http.HttpServletRequest;
    import java.util.Map;

    /**
     * @author: atguigu
     * @create: 2023-01-12 10:21
     */
    @RestController
    @RequestMapping("/api/order")
    public class OrderApiController {


        @Autowired
        private OrderInfoService orderInfoService;


        /**
         * 订单确认页面数据模型汇总
         * @param request
         * @return
         */
        @GetMapping("/auth/trade")
        public Result<Map<String, Object>> trade(HttpServletRequest request) {
            //1.获取用户ID
            String userId = AuthContextHolder.getUserId(request);
            //2.业务逻辑汇总订单确认页面数据
            Map<String, Object> map = orderInfoService.trade(userId);
            return Result.ok(map);
        }
    }
    ```
3.  在`OrderInfoService`封装确认页面相关数据
    ```java
    package com.atguigu.gmall.order.service.impl;

    import com.atguigu.gmall.cart.feign.CartFeignClient;
    import com.atguigu.gmall.cart.model.CartInfo;
    import com.atguigu.gmall.order.mapper.OrderInfoMapper;
    import com.atguigu.gmall.order.model.OrderDetail;
    import com.atguigu.gmall.order.model.OrderInfo;
    import com.atguigu.gmall.order.service.OrderInfoService;
    import com.atguigu.gmall.product.client.ProductFeignClient;
    import com.atguigu.gmall.user.client.UserFeignClient;
    import com.atguigu.gmall.user.model.UserAddress;
    import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.util.CollectionUtils;

    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;
    import java.util.stream.Collectors;

    @Service
    @SuppressWarnings("all")
    public class OrderInfoServiceImpl extends ServiceImpl<OrderInfoMapper, OrderInfo> implements OrderInfoService {

        @Autowired
        private UserFeignClient userFeignClient;

        @Autowired
        private CartFeignClient cartFeignClient;

        @Autowired
        private ProductFeignClient productFeignClient;

        /**
         * 汇总订单确认页面需要5个参数
         * 1.${userAddressList} 用户收件地址列表 --- 异步获取
         * 2.${detailArrayList} 送货清单列表
         * 3.${totalNum} 总商品数量
         * 4.${totalAmount} 订单总金额
         * 5.${tradeNo} 方式订单重复提交流水号
         *
         * @param userId
         * @return
         */
        @Override
        public Map<String, Object> trade(String userId) {
            HashMap<String, Object> result = new HashMap<>();
            //1.远程调用用户微服务获取收货地址列表
            Long userIdLong = Long.valueOf(userId);
          

            //2.远程调用购物车微服务获取选中的购物车商品-将得到CarInfo封装为OrderDetail对象
            List<CartInfo> cartCheckedList = cartFeignClient.getCartCheckedList(userIdLong);
            if (!CollectionUtils.isEmpty(cartCheckedList)) {
                List<OrderDetail> orderDetailList = cartCheckedList.stream().map(cartInfo -> {
                    OrderDetail orderDetail = new OrderDetail();
                    orderDetail.setSkuName(cartInfo.getSkuName());
                    orderDetail.setSkuId(cartInfo.getSkuId());
                    //价格 远程获取最新商品价格
                    orderDetail.setOrderPrice(productFeignClient.getSkuPrice(cartInfo.getSkuId()));
                    orderDetail.setImgUrl(cartInfo.getImgUrl());
                    orderDetail.setSkuNum(cartInfo.getSkuNum());
                    return orderDetail;
                }).collect(Collectors.toList());
                result.put("detailArrayList", orderDetailList);
                //3.总商品数量
                result.put("totalNum", cartCheckedList.size());

                //4.计算订单总金额
                OrderInfo orderInfo = new OrderInfo();
                orderInfo.setOrderDetailList(orderDetailList);
                //调用计算总金额方法
                orderInfo.sumTotalAmount();
                result.put("totalAmount", orderInfo.getTotalAmount());
            }
            //5.TODO 防止订单重复提交生成唯一流水号
            return result;
        }
    }
    ```

**说明**：接口已经封装，接下来暴露接口，提供给web-all模块前端展示数据

## 2.4 结算页面

### 2.4.1 搭建service-order-client模块

在`gmall-client`下创建子模块：service-order-client。搭建过程同service-cart-client

![](image/image-20221208003936738_zW1KEIq39x.png)

### 2.4.2 在service-order-client暴露接口

远程调用API Feign接口

```java
package com.atguigu.gmall.order.client;

import com.atguigu.gmall.common.result.Result;
import com.atguigu.gmall.order.client.impl.OrderDegradeFeignClient;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

import java.util.Map;

@FeignClient(value = "service-order", fallback = OrderDegradeFeignClient.class)
public interface OrderFeignClient {

    /**
     * 订单确认页面数据模型汇总
     * @return
     */
    @GetMapping("/api/order/auth/trade")
    public Result<Map<String, Object>> trade();
}
```

服务降级类：

```java
package com.atguigu.gmall.order.client.impl;


import com.atguigu.gmall.common.result.Result;
import com.atguigu.gmall.order.client.OrderFeignClient;
import org.springframework.stereotype.Component;

import java.util.Map;

@Component
public class OrderDegradeFeignClient implements OrderFeignClient {

    @Override
    public Result<Map<String, Object>> trade() {
        return Result.fail();
    }
}
```

微服务之间用户信息传递

![](image/wps8_4s7VK3ONGy.jpg)

如上图：因为微服务之间并没有传递头文件，所以我们可以定义一个拦截器，每次微服务调用之前都先检查下头文件，将请求的头文件中的用户信息再放入到header中，再调用其他微服务即可。

在`web-util`中添加拦截器-已经添加

```java
package com.atguigu.gmall.common.interceptor;

import javax.servlet.http.HttpServletRequest;

@Component
public class FeignInterceptor implements RequestInterceptor {

    public void apply(RequestTemplate requestTemplate){
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();

        requestTemplate.header("userTempId", request.getHeader("userTempId"));
        requestTemplate.header("userId", request.getHeader("userId"));
    }
}
```

### 2.4.3 配置网关

Nacos配置中心列表中找到`server-gateway-dev.yaml`修改增加动态路由

```yaml
- id: web-order
  uri: lb://web-all
  predicates:
  - Host=order.gmall.com
- id: service-order
  uri: lb://service-order
  predicates:
  - Path=/*/order/**
```

### 2.4.4 在web-all模块中添加依赖

```xml
<dependency>
    <groupId>com.atguigu.gmall</groupId>
    <artifactId>service-order-client</artifactId>
    <version>1.0</version>
</dependency>
```

### 2.4.5 在web-all中添加控制器

```java
package com.atguigu.gmall.web.controller;

import com.atguigu.gmall.common.result.Result;
import com.atguigu.gmall.common.util.AuthContextHolder;
import com.atguigu.gmall.order.client.OrderFeignClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

import javax.servlet.http.HttpServletRequest;
import java.util.Map;

/**
 * @author: atguigu
 * @create: 2023-01-12 10:56
 */
@Controller
public class OrderController {

    @Autowired
    private OrderFeignClient orderFeignClient;

    /**
     * 订单确认页面渲染
     * @param model
     * @return
     */
    @GetMapping("/trade.html")
    public String trade(Model model){
        Result<Map<String, Object>> result = orderFeignClient.trade();
        model.addAllAttributes(result.getData());
        return "/order/trade.html";
    }
}
```

# 3、下订单

![](image/wps9_FRv3ZQJZtD.jpg)

## 3.1 下单功能分析：

1.  防止订单重复提交
2.  **保存单据: orderInfo orderDetail。**
3.  保存以后把购物车中的商品删除。{不删！}
4.  重定向到支付页面。

> YAPI接口地址：[http://192.168.200.128:3000/project/11/interface/api/771](http://192.168.200.128:3000/project/11/interface/api/771 "http://192.168.200.128:3000/project/11/interface/api/771")

## 3.2 编写控制器

`service-order`模块中：OrderApiController

```java
/**
 * 提交订单
 * @param orderInfo
 * @param request
 * @return
 */
@PostMapping("auth/submitOrder")
public Result submitOrder(@RequestBody OrderInfo orderInfo, HttpServletRequest request) {
    // 获取到用户Id
    String userId = AuthContextHolder.getUserId(request);
    orderInfo.setUserId(Long.parseLong(userId));

    // 验证通过，保存订单！
    Long orderId = orderInfoService.saveOrderInfo(orderInfo);
    return Result.ok(orderId);
}
```

## 3.3 添加接口与实现类

订单业务接口：OrderService

```java
package com.atguigu.gmall.order.service;

import com.atguigu.gmall.order.model.OrderInfo;
import com.baomidou.mybatisplus.extension.service.IService;

public interface OrderInfoService extends IService<OrderInfo> {

    /**
     * 保存订单
     * @param orderInfo
     * @return
     */
    Long saveOrderInfo(OrderInfo orderInfo);
}
```

订单业务实现类：OrderServiceImpl

```java
package com.atguigu.gmall.order.service.impl;


import com.atguigu.gmall.enums.model.OrderStatus;
import com.atguigu.gmall.enums.model.ProcessStatus;
import com.atguigu.gmall.order.model.OrderDetail;
import com.atguigu.gmall.order.model.OrderInfo;
import com.atguigu.gmall.order.mapper.OrderDetailMapper;
import com.atguigu.gmall.order.mapper.OrderInfoMapper;
import com.atguigu.gmall.order.service.OrderService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Calendar;
import java.util.Date;
import java.util.List;

@Service
public class OrderInfoServiceImpl extends ServiceImpl<OrderInfoMapper, OrderInfo> implements OrderService {

    @Autowired
    private OrderInfoMapper orderInfoMapper;

    @Autowired
    private OrderDetailMapper orderDetailMapper;

    @Override
    @Transactional
    public Long saveOrderInfo(OrderInfo orderInfo) {
        orderInfo.sumTotalAmount();
        orderInfo.setOrderStatus(OrderStatus.UNPAID.name());
        String outTradeNo = "ATGUIGU" + System.currentTimeMillis() + "" + new Random().nextInt(1000);
        orderInfo.setOutTradeNo(outTradeNo);
        orderInfo.setCreateTime(new Date());
        // 定义为1天
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DATE, 1);
        orderInfo.setExpireTime(calendar.getTime());

        orderInfo.setProcessStatus(ProcessStatus.UNPAID.name());
        // 获取订单明细
        List<OrderDetail> orderDetailList = orderInfo.getOrderDetailList();
        StringBuffer tradeBody = new StringBuffer();
        for (OrderDetail orderDetail : orderDetailList) {
            tradeBody.append(orderDetail.getSkuName() + " ");
        }
        if (tradeBody.toString().length() > 100) {
            orderInfo.setTradeBody(tradeBody.toString().substring(0, 100));
        } else {
            orderInfo.setTradeBody(tradeBody.toString());
        }

        orderInfoMapper.insert(orderInfo);

        for (OrderDetail orderDetail : orderDetailList) {
            orderDetail.setOrderId(orderInfo.getId());
            orderDetailMapper.insert(orderDetail);
        }
        return orderInfo.getId();
    }
}

```

## 3.4 添加mapper

订单信息Mapper

```java
package com.atguigu.gmall.order.mapper;


import com.atguigu.gmall.order.model.OrderInfo;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

public interface OrderInfoMapper extends BaseMapper<OrderInfo> {

}
```

```java
package com.atguigu.gmall.order.mapper;

import com.atguigu.gmall.order.model.OrderDetail;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

public interface OrderDetailMapper extends BaseMapper<OrderDetail> {
}
```

## 3.5 如何解决用户利用浏览器回退重复提交订单？

​	在进入结算页面时，生成一个结算流水号，然后保存到结算页面的隐藏元素中，每次用户提交都检查该流水号与页面提交的是否相符，订单保存以后把后台的流水号删除掉。那么第二次用户用同一个页面提交的话流水号就会匹配失败，无法重复保存订单。

### 3.5.1 修改结算页增加流水号的生成

OrderInfoService接口

```java
/**
 * 生成流水号-防止订单重复提交
 * @param userId
 * @return
 */
String getTradeCode(String userId);

/**
 * 验证流水号是否一致 - 原子判断删除采用Lua脚本优化
 * @param userId
 * @param tradeCode
 * @return
 */
//Boolean checkTradeCode(String userId, String tradeCode);


/**
 * 删除流水号 - 原子判断删除采用Lua脚本优化
 * @param userId
 */
//void deleteTradeCode(String userId);
```

OrderInfoServiceImpl实现类

```java
@Autowired
private RedisTemplate redisTemplate;


/**
 * 生成流水号
 *
 * @param userId
 * @return
 */
//@Override
public String getTradeCode(String userId) {
    String tradeKey = "user:" + userId + ":tradecode";
    String uuid = UUID.randomUUID().toString().replaceAll("-", "");
    redisTemplate.opsForValue().set(tradeKey, uuid);
    return uuid;
}

/**
 * 校验流水号是否一致
 *
 * @param userId
 * @param tradeCode
 * @return
 */
//@Override
//public Boolean checkTradeCode(String userId, String tradeCode) {
//    String tradeKey = "user:" + userId + ":tradecode";
//    //1.获取redis中正确的流水号
//    String redisTradCode = (String) redisTemplate.opsForValue().get(tradeKey);
//    //2.判断比较是否一致
//    return tradeCode.equals(redisTradCode);
//}

/**
 * 删除流水号
 *
 * @param userId
 */
//@Override
//public void deleteTradeCode(String userId) {
//    String tradeKey = "user:" + userId + ":tradecode";
//    redisTemplate.delete(tradeKey);
//}
```

### 3.5.2 在OrderController类trade方法添加交易流水号

修改com.atguigu.gmall.order.service.OrderInfoService#trade方法

```java
//5.TODO 防止订单重复提交生成唯一流水号
String tradeCode = getTradeCode(userId);
result.put("tradeNo", tradeCode);
```

### 3.5.3 在OrderApiController控制器中实现

修改com.atguigu.gmall.order.controller.OrderApiController#submitOrder方法

```java
//TODO 1.防止订单重复提交 如果判断+删除java代码实现 不是原子操作我们选择Lua脚本来保证原子执行
//  提交时，验证流水号：
String script = "if redis.call(\"get\",KEYS[1]) == ARGV[1]\n" +
        "then\n" +
        "    return redis.call(\"del\",KEYS[1])\n" +
        "else\n" +
        "    return 0\n" +
        "end";
String tradeKey = "user:" + userId + ":tradecode";
DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
redisScript.setScriptText(script);
redisScript.setResultType(Long.class);
Long result = (Long) redisTemplate.execute(redisScript, Arrays.asList(tradeKey), tradeNo);
if(result==0){
    //需要在全局异常处理类中，将提示消息显示Result.fail().message(e.getMessage());
    throw new RuntimeException("请勿重复提交订单！");
}
```

## 3.6 验库存与验证价格

通过restful接口查询商品是否有库存

一般电商系统的商品库存，都不由电商系统本身来管理，由另外一套仓库管理系统，或者进销存系统来管理，电商系统通过第三方接口调用该系统。

由于库管系统可能是异构的系统，所以不在微服务体系之内。只支持restful风格的webservice调用和消息队列的调用。

详见《库存管理系统》

根据手册中的接口文档，编写调用代码。

### 3.6.1 导入项目ware-manage项目

详情查看库存管理系统文档，把资料中的ware-manage项目直接放入到项目模块目录下。

![](image/wps10_xfnpB2k9sB.jpg)

打开库存项目

![](image/wps11_ldfb-ZB4NM.jpg)

![](image/wps12_AZR_A5Bq2Z.jpg)

点击OK.

![](image/wps13_TE26kHkNgB.jpg)

**注意：****注意：** 导入后修改下库存系统工程中父工程的坐标信息；修改数据库连接信息；注释掉mybatisPlus配置 导入后修改下库存系统工程中父工程的坐标信息；修改数据库连接信息；注释掉mybatisPlus配置

填写库存信息！

可以访问库存系统：[http://localhost:9001/index](http://www.gware.com/index "http://localhost:9001/index")

验证库存：

![](image/wps14_Cm7mh0Jd7S.jpg)

添加商品库存的时候，商品的库存应该选择同一个库存！

![](image/wps15_wrP2gAS8Zb.jpg)

### 3.6.2 查询仓库数量，进行校验

现在验证库存数量方法

在orderService接口中定义验库存接口

```java
/**
 * 验证库存
 * @param skuId
 * @param skuNum
 * @return
 */
boolean checkStock(Long skuId, Integer skuNum);
```

实现类OrderInfoServiceImpl

```java

@Value("${ware.url}")
private String WARE_URL;

@Override
public boolean checkStock(Long skuId, Integer skuNum) {
    // 远程调用http://localhost:9001/hasStock?skuId=10221&num=2
    String result = HttpClientUtil.doGet(WARE_URL + "/hasStock?skuId=" + skuId + "&num=" + skuNum);
    return "1".equals(result);
}

```

### 3.6.3 submitOrder中增加 方法

```java
/**
 * 订单保存业务
 * 1.防止订单重复提交
 * 2.验证每件商品库存是否充足，商品价格是否为最新
 * 3.保存订单以及订单详情
 * 4.购物车中中结算商品删除
 * 5.返回订单ID
 *
 * @param orderInfo 订单信息
 * @param tradeNo   用户提交流水号
 * @return
 */
@Override
public Long submitOrder(OrderInfo orderInfo, String tradeNo) {
    //1.防止订单重复提交 如果判断+删除java代码实现 不是原子操作
    String userId = orderInfo.getUserId().toString();
    //Boolean flag = this.checkTradeCode(userId, tradeNo);
    //if (!flag) {
    //    //抛出运行时异常或者自定义异常，封装错误提示信息给前端
    //    throw new RuntimeException("请勿重复提交订单！");
    //}
    //this.deleteTradeCode(userId);
    //KEYS[1]:用户流水号Key  ARGV[1]:用户提交流水号
    String script = "if redis.call(\"get\",KEYS[1]) == ARGV[1]\n" +
            "then\n" +
            "    return redis.call(\"del\",KEYS[1])\n" +
            "else\n" +
            "    return 0\n" +
            "end";
    String tradeKey = "user:" + userId + ":tradecode";
    DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
    redisScript.setScriptText(script);
    redisScript.setResultType(Long.class);
    Long result = (Long) redisTemplate.execute(redisScript, Arrays.asList(tradeKey), tradeNo);
    if (result == 0) {
        throw new RuntimeException("请勿重复提交订单！");
    }

    //2.验证每件商品库存是否充足，商品价格是否为最新
    //2.1 获取订单中订单详情中商品列表
    List<String> errorMsgList = new ArrayList<>();
    List<OrderDetail> orderDetails = orderInfo.getOrderDetailList();
    if (!CollectionUtils.isEmpty(orderDetails)) {
        String userCartKey = "user:" + userId + ":cart";
        BoundHashOperations<String, String, CartInfo> hashOps = redisTemplate.boundHashOps(userCartKey);
        //2.1遍历过程中判断每个商品库存以及价格是否合法
        for (OrderDetail orderDetail : orderDetails) {
            //2.2检验库存
            String checkStockUrl = "http://localhost:9001/hasStock?skuId=" + orderDetail.getSkuId() + "&num=" + orderDetail.getSkuNum();
            String stockResult = HttpClientUtil.doGet(checkStockUrl);
            if ("0".equals(stockResult)) {
                errorMsgList.add(orderDetail.getSkuName() + "库存不足");
            }
            //2.3查询价格是否为商品最新价格
            BigDecimal skuPrice = productFeignClient.getSkuPrice(orderDetail.getSkuId());
            if (orderDetail.getOrderPrice().compareTo(skuPrice) != 0) {
                //价格不一致
                errorMsgList.add(orderDetail.getSkuName() + "价格失效");
                //2.4修改redis中用户购物车中价格改为最新
                CartInfo cartInfo = hashOps.get(orderDetail.getSkuId().toString());
                cartInfo.setSkuPrice(skuPrice);
                hashOps.put(orderDetail.getSkuId().toString(), cartInfo);
            }
        }
    }
    if (!CollectionUtils.isEmpty(errorMsgList)) {
        throw new RuntimeException(StringUtils.join(errorMsgList, ","));
    }

    //3.保存订单以及订单详情
    //3.1 封装订单相关属性
    orderInfo.sumTotalAmount();
    orderInfo.setOrderStatus(OrderStatus.UNPAID.name());
    orderInfo.setPaymentWay(PaymentWay.ONLINE.name());
    String outTradeNo = "ATGUIGU" + System.currentTimeMillis() + new Random().nextInt(1000);
    orderInfo.setOutTradeNo(outTradeNo);
    orderInfo.setProcessStatus(ProcessStatus.UNPAID.name());
    StringBuilder stringBuilder = new StringBuilder();
    for (OrderDetail orderDetail : orderDetails) {
        stringBuilder.append(orderDetail.getSkuName() + " ");
    }
    if (stringBuilder.toString().length() > 100) {
        orderInfo.setTradeBody(stringBuilder.toString().substring(0, 100));
    } else {
        orderInfo.setTradeBody(stringBuilder.toString());
    }
    orderInfo.setImgUrl(orderDetails.get(0).getImgUrl());
    orderInfo.setOperateTime(new Date());
    Calendar calendar = Calendar.getInstance();
    calendar.add(Calendar.DATE, 1);
    orderInfo.setExpireTime(calendar.getTime());
    //3.2 将订单保存
    this.save(orderInfo);
    //3.3 封装订单详情对象 保存订单详情
    List<OrderDetail> orderDetailList = orderDetails.stream().map(orderDetail -> {
        orderDetail.setOrderId(orderInfo.getId());
        return orderDetail;
    }).collect(Collectors.toList());
    //3.4 批量新增订单详情
    if (!CollectionUtils.isEmpty(orderDetailList)) {
        orderDetailService.saveBatch(orderDetailList);
    }

    //TODO 4.购物车中中结算商品删除
    //5.返回订单ID
    return orderInfo.getId();
}
```

### 3.6.4 优化下单

下单我们要校验库存与价格，请求比较多，时间比较长，我们可以通过异步编排的形式减少请求时间，异步编排我们前面已经学习过了，接下来怎么做呢

#### 3.6.4.1 引入线程类

将service-item下面的config线程池配置类copy到`service-order`过来

```java
package com.atguigu.gmall.order.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

@Configuration
public class ThreadPoolConfig {

    /**
     *
     * public ThreadPoolExecutor(int corePoolSize,
     *                               int maximumPoolSize,
     *                               long keepAliveTime,
     *                               TimeUnit unit,
     *                               BlockingQueue<Runnable> workQueue,
     *                               ThreadFactory threadFactory,
     *                               RejectedExecutionHandler handler)
     * 构造函数的参数含义如下：
     *
     * corePoolSize:指定了线程池中的线程数量，它的数量决定了添加的任务是开辟新的线程去执行，还是放到workQueue任务队列中去；
     * maximumPoolSize:指定了线程池中的最大线程数量，这个参数会根据你使用的workQueue任务队列的类型，决定线程池会开辟的最大线程数量；
     * keepAliveTime:当线程池中空闲线程数量超过corePoolSize时，多余的线程会在多长时间内被销毁；
     * unit:keepAliveTime的单位
     * workQueue:任务队列，被添加到线程池中，但尚未被执行的任务；它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列几种；
     * threadFactory:线程工厂，用于创建线程，一般用默认即可；
     * handler:拒绝策略；当任务太多来不及处理时，如何拒绝任务；
     * @return
     */
    @Bean
    public ThreadPoolExecutor threadPoolExecutor(){

        return new ThreadPoolExecutor(50, 500, 30, TimeUnit.SECONDS, new ArrayBlockingQueue<>(10000));
    }
}
```

#### 3.6.4.2 调整下单类

```java
@Autowired
private ThreadPoolExecutor threadPoolExecutor;

/**
 * 订单保存业务
 * 1.防止订单重复提交
 * 2.验证每件商品库存是否充足，商品价格是否为最新
 * 3.保存订单以及订单详情
 * 4.购物车中中结算商品删除
 * 5.返回订单ID
 *
 * @param orderInfo 订单信息
 * @param tradeNo   用户提交流水号
 * @return
 */
@Override
public Long submitOrder(OrderInfo orderInfo, String tradeNo) {
    //1.防止订单重复提交 如果判断+删除java代码实现 不是原子操作
    String userId = orderInfo.getUserId().toString();
    //Boolean flag = this.checkTradeCode(userId, tradeNo);
    //if (!flag) {
    //    //抛出运行时异常或者自定义异常，封装错误提示信息给前端
    //    throw new RuntimeException("请勿重复提交订单！");
    //}
    //this.deleteTradeCode(userId);
    //KEYS[1]:用户流水号Key  ARGV[1]:用户提交流水号
    String script = "if redis.call(\"get\",KEYS[1]) == ARGV[1]\n" +
            "then\n" +
            "    return redis.call(\"del\",KEYS[1])\n" +
            "else\n" +
            "    return 0\n" +
            "end";
    String tradeKey = "user:" + userId + ":tradecode";
    DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
    redisScript.setScriptText(script);
    redisScript.setResultType(Long.class);
    Long result = (Long) redisTemplate.execute(redisScript, Arrays.asList(tradeKey), tradeNo);
    if (result == 0) {
        throw new RuntimeException("请勿重复提交订单！");
    }

    //2.验证每件商品库存是否充足，商品价格是否为最新
    //2.1 获取订单中订单详情中商品列表
    List<String> errorMsgList = new ArrayList<>();
    //声明集合存放异步任务
    List<CompletableFuture> futureArrayList = new ArrayList<>();
    List<OrderDetail> orderDetails = orderInfo.getOrderDetailList();
    if (!CollectionUtils.isEmpty(orderDetails)) {
        String userCartKey = "user:" + userId + ":cart";
        BoundHashOperations<String, String, CartInfo> hashOps = redisTemplate.boundHashOps(userCartKey);
        //2.1遍历过程中判断每个商品库存以及价格是否合法
        for (OrderDetail orderDetail : orderDetails) {
            //2.2检验库存
            CompletableFuture<Void> stockCompletableFuture = CompletableFuture.runAsync(() -> {
                String checkStockUrl = "http://localhost:9001/hasStock?skuId=" + orderDetail.getSkuId() + "&num=" + orderDetail.getSkuNum();
                String stockResult = HttpClientUtil.doGet(checkStockUrl);
                if ("0".equals(stockResult)) {
                    errorMsgList.add(orderDetail.getSkuName() + "库存不足");
                }
            }, threadPoolExecutor);
            futureArrayList.add(stockCompletableFuture);


            //2.3查询价格是否为商品最新价格
            CompletableFuture<Void> priceCompletableFuture = CompletableFuture.runAsync(() -> {
                BigDecimal skuPrice = productFeignClient.getSkuPrice(orderDetail.getSkuId());
                if (orderDetail.getOrderPrice().compareTo(skuPrice) != 0) {
                    //价格不一致
                    errorMsgList.add(orderDetail.getSkuName() + "价格失效");
                    //2.4修改redis中用户购物车中价格改为最新
                    CartInfo cartInfo = hashOps.get(orderDetail.getSkuId().toString());
                    cartInfo.setSkuPrice(skuPrice);
                    hashOps.put(orderDetail.getSkuId().toString(), cartInfo);
                }
            }, threadPoolExecutor);
            futureArrayList.add(priceCompletableFuture);
        }
    }
    //2.5 多个任务组合执行-并行执行
    CompletableFuture.allOf(futureArrayList.toArray(new CompletableFuture[futureArrayList.size()])).join();

    if (!CollectionUtils.isEmpty(errorMsgList)) {
        throw new RuntimeException(StringUtils.join(errorMsgList, ","));
    }

    //3.保存订单以及订单详情
    //3.1 封装订单相关属性
    orderInfo.sumTotalAmount();
    orderInfo.setOrderStatus(OrderStatus.UNPAID.name());
    orderInfo.setPaymentWay(PaymentWay.ONLINE.name());
    String outTradeNo = "ATGUIGU" + System.currentTimeMillis() + new Random().nextInt(1000);
    orderInfo.setOutTradeNo(outTradeNo);
    orderInfo.setProcessStatus(ProcessStatus.UNPAID.name());
    StringBuilder stringBuilder = new StringBuilder();
    for (OrderDetail orderDetail : orderDetails) {
        stringBuilder.append(orderDetail.getSkuName() + " ");
    }
    if (stringBuilder.toString().length() > 100) {
        orderInfo.setTradeBody(stringBuilder.toString().substring(0, 100));
    } else {
        orderInfo.setTradeBody(stringBuilder.toString());
    }
    orderInfo.setImgUrl(orderDetails.get(0).getImgUrl());
    orderInfo.setOperateTime(new Date());
    Calendar calendar = Calendar.getInstance();
    calendar.add(Calendar.DATE, 1);
    orderInfo.setExpireTime(calendar.getTime());
    //3.2 将订单保存
    this.save(orderInfo);
    //3.3 封装订单详情对象 保存订单详情
    List<OrderDetail> orderDetailList = orderDetails.stream().map(orderDetail -> {
        orderDetail.setOrderId(orderInfo.getId());
        return orderDetail;
    }).collect(Collectors.toList());
    //3.4 批量新增订单详情
    if (!CollectionUtils.isEmpty(orderDetailList)) {
        orderDetailService.saveBatch(orderDetailList);
    }

    //TODO 4.购物车中中结算商品删除
    //5.返回订单ID
    return orderInfo.getId();
}
```

# 4、我的订单

> YAPI接口地址：[http://192.168.200.128:3000/project/11/interface/api/763](http://192.168.200.128:3000/project/11/interface/api/763 "http://192.168.200.128:3000/project/11/interface/api/763")

## 4.4 添加controller接口

在OrderApiController类添加处理我的订单列表方法

```java
@GetMapping("/auth/{page}/{limit}")
public Result getOrder(@PathVariable Long page,
                       @PathVariable Long limit,
                       HttpServletRequest request){
    //  查看我的订单. userId
    String userId = AuthContextHolder.getUserId(request);
    //  获取订单状态,
    String orderStatus = request.getParameter("orderStatus");
    //  带分页的查询
    Page<OrderInfo> orderInfoPage = new Page<>(page,limit);
    //  调用服务层方法.
    IPage<OrderInfo> infoIPage = this.orderService.getOrder(orderInfoPage,userId,orderStatus);
    //  返回封装的数据
    return Result.ok(infoIPage);
}
```

## 4.1 添加service接口

在OrderService类添加接口

```java
/**
 * 查看我的订单.
 * @param orderInfoPage
 * @param userId
 * @param orderStatus
 * @return
 */
IPage<OrderInfo> getOrder(Page<OrderInfo> orderInfoPage, String userId, String orderStatus);
```

## 4.2 添加service接口实现

在OrderServiceImpl类添加接口实现

```java
@Override
public IPage<OrderInfo> getOrder(Page<OrderInfo> orderInfoPage, String userId, String orderStatus) {
    //  有订单，就需要有订单明细.
    IPage<OrderInfo> infoIPage = orderInfoMapper.selectOrder(orderInfoPage,userId,orderStatus);
    //  需要编写一个订单的状态名称. order.orderStatusName ,循环遍历订单，根据订单的状态获取订单的名称.
    infoIPage.getRecords().forEach(orderInfo -> {
        String statusNameByStatus = OrderStatus.getStatusNameByStatus(orderInfo.getOrderStatus());
        orderInfo.setOrderStatusName(statusNameByStatus);
    });
    return infoIPage;
}
```

## 4.3 添加mapper接口

1.  在OrderInfoMapper类添加接口
    ```java
    package com.atguigu.gmall.order.mapper;


    import com.atguigu.gmall.order.model.OrderInfo;
    import com.baomidou.mybatisplus.core.mapper.BaseMapper;
    import com.baomidou.mybatisplus.core.metadata.IPage;
    import com.baomidou.mybatisplus.extension.plugins.pagination.Page;

    public interface OrderInfoMapper extends BaseMapper<OrderInfo> {

        IPage<OrderInfo> selectOrder(Page<OrderInfo> orderInfoPage, String userId, String orderStatus);
    }

    ```
2.  添加接口对应的xml文件方法
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE mapper SYSTEM "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
    <mapper namespace="com.atguigu.gmall.order.mapper.OrderInfoMapper">
        <resultMap id="OrderInfoMap" type="com.atguigu.gmall.order.model.OrderInfo" autoMapping="true">
            <!--映射主键的-->
            <id property="id" column="id"></id>
            <!--配置一对多-->
            <collection property="orderDetailList" ofType="com.atguigu.gmall.order.model.OrderDetail" autoMapping="true">
                <id property="id" column="detail_id"></id>
            </collection>
        </resultMap>

        <select id="selectOrder" resultMap="OrderInfoMap">
            select
            oi.id,
            oi.consignee,
            oi.consignee_tel,
            oi.total_amount,
            oi.order_status,
            oi.user_id,
            oi.payment_way,
            oi.delivery_address,
            oi.order_comment,
            oi.out_trade_no,
            oi.trade_body,
            oi.create_time,
            oi.expire_time,
            oi.process_status,
            od.id detail_id,
            od.order_id,
            od.sku_id,
            od.sku_name,
            od.img_url,
            od.order_price,
            od.sku_num,
            od.create_time
            from order_info oi
            inner join order_detail od
            on oi.id = od.order_id
            <where>
                user_id = #{userId}
                and oi.order_status = 'SPLIT'
                <if test="orderStatus!=null and orderStatus!=''">
                    and oi.order_status = #{orderStatus}
                </if>
            </where>
            ORDER BY oi.id DESC
        </select>
    </mapper>
    ```

## 4.5 web-all 中添加控制器

OrderController

```java
/**
 * 我的订单
 * @return
 */
@GetMapping("myOrder.html")
public String myOrder() {
    return "order/myOrder";
}
```
