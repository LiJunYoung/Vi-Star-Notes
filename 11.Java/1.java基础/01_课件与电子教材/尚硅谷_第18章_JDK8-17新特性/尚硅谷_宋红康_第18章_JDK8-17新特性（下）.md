# 第18章_JDK8-17新特性（下）

讲师：尚硅谷-宋红康（江湖人称：康师傅）

官网：[http://www.atguigu.com](http://www.atguigu.com/)

***

## 6. 新语法结构

### 6.1 Java的REPL工具： jShell命令

这是JDK9的新特性。

**产生背景**

像Python 和 Scala 之类的语言早就有交互式编程环境 REPL (read - evaluate - print - loop)了，以交互式的方式对语句和表达式进行求值。开发者只需要输入一些代码，就可以在编译前获得对程序的反馈。而之前的Java版本要想执行代码，必须创建文件、声明类、提供测试方法方可实现。

**设计理念**

即写即得、快速运行

**实现目标**

Java 9 中终于拥有了 REPL工具：jShell。利用jShell在没有创建类的情况下直接声明变量，计算表达式，执行语句。即开发时可以在命令行里直接运行Java的代码，而无需创建Java文件，无需跟人解释”public static void main(String[] args)”这句废话。

jShell也可以从文件中加载语句或者将语句保存到文件中。

jShell也可以是tab键进行自动补全和自动添加分号。

**使用举例**

调出jShell

 ![image-20220527205410620](images/image-20220527205410620.png)

获取帮助

 ![image-20220527205418073](images/image-20220527205418073.png)

基本使用

 ![image-20220527205423734](images/image-20220527205423734.png)

 ![image-20220527205429720](images/image-20220527205429720.png)

> Tips：在 JShell 环境下，语句末尾的“;” 是可选的。但推荐还是最好加上。提高代码可读性。

导入指定的包

 ![image-20220527205440068](images/image-20220527205440068.png)

默认已经导入如下的所有包：（包含java.lang包）

 ![image-20220527205445267](images/image-20220527205445267.png)

只需按下 Tab 键，就能自动补全代码

 ![image-20220527205451352](images/image-20220527205451352.png)

列出当前 session 里所有有效的代码片段

 ![image-20220527205458774](images/image-20220527205458774.png)

查看当前 session 下所有创建过的变量

 ![image-20220527205506632](images/image-20220527205506632.png)

查看当前 session 下所有创建过的方法

 ![image-20220527205513459](images/image-20220527205513459.png)

> Tips：我们还可以重新定义相同方法名和参数列表的方法，即为对现有方法的修改（或覆盖）。

使用外部代码编辑器来编写 Java 代码

 ![image-20220527205519915](images/image-20220527205519915.png)

从外部文件加载源代码

```java
/**
 * Created by songhongkang on 2017/12/27 0020.
 */
public void printHello() {
    System.out.println("马上2018年了，尚硅谷祝所有的谷粉元旦快乐！");
}
printHello();

```

使用/open命令调用：

 ![image-20220527205827712](images/image-20220527205827712.png)

没有受检异常（编译时异常）

 ![image-20220527205842572](images/image-20220527205842572.png)

> 说明：本来应该强迫我们捕获一个IOException，但却没有出现。因为jShell在后台为我们隐藏了。

退出jShell

 ![image-20220527205904000](images/image-20220527205904000.png)

### 6.2 异常处理之try-catch

在JDK7 之前，我们习惯于这样处理资源的关闭：

```java
@Test
public void test01() {
    FileWriter fw = null;
    BufferedWriter bw = null;
    try {
        fw = new FileWriter("d:/1.txt");
        bw = new BufferedWriter(fw);

        bw.write("hello");
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try {
            if (bw != null) {
                bw.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            if (fw != null) {
                fw.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```

JDK7新增的语法，称为try...catch...with...resource，可以实现资源的自动关闭，但是要求执行后必须关闭的所有资源必须在try子句中初始化，否则编译不通过。

语法格式：

```java
try(资源对象的声明和初始化){
    业务逻辑代码
}catch(异常类型1 e){
    处理异常代码
}catch(异常类型2 e){
    处理异常代码
}
....
```

这个形式的try...catch，没有finally。这种格式可以保证在try()中声明的资源，无论是否发生异常，无论是否处理异常，都不需要程序员去关闭资源对象，都会自动关闭资源对象。

需要指出的是，为了保证try语句可以正常关闭资源，这些资源实现类必须实现AutoCloseable或Closeable接口，实现这两个接口就必须实现close方法。Closeable是AutoCloseable的子接口。Java7几乎把所有的“资源类”（包括文件IO的各种类、JDBC编程的Connection、Statement等接口…）进行了改写，改写后资源类都是实现了AutoCloseable或Closeable接口，并实现了close方法。

写到try()中的资源类的变量默认是final声明的，不能修改。

举例：

```java
//举例1
@Test
public void test02() {
    try (
        FileWriter fw = new FileWriter("d:/1.txt");
        BufferedWriter bw = new BufferedWriter(fw);
    ) {
        bw.write("hello");
    } catch (IOException e) {
        e.printStackTrace();
    }
}

//举例2
@Test
public void test03() {
    //从d:/1.txt(utf-8)文件中，读取内容，写到项目根目录下1.txt(gbk)文件中
    try (
        FileInputStream fis = new FileInputStream("d:/1.txt");
        InputStreamReader isr = new InputStreamReader(fis, "utf-8");
        BufferedReader br = new BufferedReader(isr);

        FileOutputStream fos = new FileOutputStream("1.txt");
        OutputStreamWriter osw = new OutputStreamWriter(fos, "gbk");
        BufferedWriter bw = new BufferedWriter(osw);
    ) {
        String str;
        while ((str = br.readLine()) != null) {
            bw.write(str);
            bw.newLine();
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

Java 9 中，用资源语句编写try将更容易，我们可以在try子句中使用已经初始化过的资源，此时的资源是final的：

```java
@Test
public void test04() {
    InputStreamReader reader = new InputStreamReader(System.in);
    OutputStreamWriter writer = new OutputStreamWriter(System.out);
    try (reader; writer) {
        //reader是final的，不可再被赋值
        //   reader = null;

    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

### 6.3 局部变量类型推断

这是JDK 10的新特性。

**产生背景**

开发者经常抱怨Java中引用代码的程度。局部变量的显示类型声明，常常被认为是不必须的，给一个好听的名字经常可以很清楚的表达出下面应该怎样继续。

试图通过减少编写Java代码相关的仪式，允许开发人员省略通常不必要的局部变量类型声明以增强Java语言的体验性。此功能可以这样声明，如

```java
var list= new ArrayList<String>();
```

**好处**

减少了啰嗦和形式的代码，避免了信息冗余，而且对齐了变量名，更容易阅读！

**使用举例**

```java
//1.局部变量的初始化
var list = new ArrayList<>();

//2.增强for循环中的索引
for(var v : list) {
    System.out.println(v);
}

//3.传统for循环中
for(var i = 0;i < 100;i++) {
    System.out.println(i);
}
```

**适用场景：**

`场景一：类实例化时`

作为 Java开发者，在声明一个变量时，我们总是习惯了敲打两次变量类型，第一次用于声明变量类型，第二次用于构造器。

```java
LinkedHashSet<Integer> set = new LinkedHashSet<>();
```

`场景二：返回值类型含复杂泛型结构`

变量的声明类型书写复杂且较长，尤其是加上泛型的使用

```java
Iterator<Map.Entry<Integer, Student>> iterator = set.iterator();
```

**不适用场景**

初始值为null

 ![image-20220528155416900](images/image-20220528155416900.png)

Lambda表达式

 ![image-20220528155423180](images/image-20220528155423180.png)

方法引用

 ![image-20220528155429055](images/image-20220528155429055.png)

为数组静态初始化

 ![image-20220528155436304](images/image-20220528155436304.png)

没有初始化的局部变量声明

 ![image-20220528155525774](images/image-20220528155525774.png)

方法的返回类型

 ![image-20220528155537713](images/image-20220528155537713.png)

方法的参数类型

 ![image-20220528155549303](images/image-20220528155549303.png)

构造器的参数类型

 ![image-20220528155614708](images/image-20220528155614708.png)

属性

 ![image-20220528155628337](images/image-20220528155628337.png)

catch块

 ![image-20220528155640498](images/image-20220528155640498.png)

**工作原理**

在处理 var时，编译器先是查看表达式右边部分，也就是所谓的构造器，并将它作为变量的类型，然后将该类型写入字节码当中。

**注意：**

- var不是一个关键字

你不需要担心变量名或方法名会与 var发生冲突，因为 var实际上并不是一个关键字，而是一个类型名，只有在编译器需要知道类型的地方才需要用到它。除此之外，它就是一个普通合法的标识符。也就是说，除了不能用它作为类名，其他的都可以，但极少人会用它作为类名。

- 这不是JavaScript

首先我要说明的是，var并不会改变 Java是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。

下面是使用 IntelliJ（实际上是 Fernflower的反编译器）反编译器反编译出的代码：

```java
URL codefx = new URL("http://codefx.org");  
URLConnection connection = codefx.openConnection();  
BufferedReader reader = new BufferedReader( newInputStreamReader(connection.getInputStream()));  
```

 从代码来看，就好像之前已经声明了这些类型一样。事实上，这一特性只发生在编译阶段，与运行时无关，所以对运行时的性能不会产生任何影响。所以请放心，这不是 JavaScript。

### 6.4 switch表达式

**jdk12中预览特性：**

1.传统switch的弊端

传统的switch声明语句(switch statement)在使用中有一些问题：

- 匹配是自上而下的，如果忘记写break, 后面的case语句不论匹配与否都会执行；
- 所有的case语句共用一个块范围，在不同的case语句定义的变量名不能重复；
- 不能在一个case里写多个执行结果一致的条件；
- 整个switch不能作为表达式返回值；

Java 12将会对switch声明语句进行扩展，可将其作为增强版的 switch 语句或称为 "switch 表达式"来写出更加简化的代码。

2.何为预览语言？

**Switch 表达式也是作为预览语言功能的第一个语言改动被引入新版 Java 中来的**，预览语言功能的想法是在 2018 年初被引入 Java 中的，**本质上讲，这是一种引入新特性的测试版的方法。**通过这种方式，能够根据用户反馈进行升级、更改，在极端情况下，如果没有被很好的接纳，则可以完全删除该功能。预览功能的关键在于它们没有被包含在 Java SE 规范中。

3.语法详解

扩展的 switch 语句，不仅可以作为语句（statement），还可以作为表达式（expression），并且两种写法都可以使用传统的 switch 语法，或者使用简化的“case L ->”模式匹配语法作用于不同范围并控制执行流。这些更改将简化日常编码工作，并为 switch 中的模式匹配（JEP 305）做好准备。

- 使用 Java 12 中 Switch 表达式的写法，省去了 break 语句，避免了因少写 break 而出错。

- 同时将多个 case 合并到一行，显得简洁、清晰也更加优雅的表达逻辑分支，其具体写法就是将之前的 case 语句表成了：case L ->，即如果条件匹配 case L，则执行标签右侧的代码 ，同时标签右侧的代码段只能是表达式、代码块或 throw 语句。

- 为了保持兼容性，case 条件语句中依然可以使用字符 : ，这时 fall-through 规则依然有效的，即不能省略原有的 break 语句，但是同一个 Switch 结构里不能混用 -> 和 : ，否则会有编译错误。并且简化后的 Switch 代码块中定义的局部变量，其作用域就限制在代码块中，而不是蔓延到整个 Switch 结构，也不用根据不同的判断条件来给变量赋值。

4.代码举例

举例1：

Java 12之前

```java
/**
 * @author shkstart
 * @create 2019 下午 4:47
 */
public class SwitchTest {
    public static void main(String[] args) {
        int numberOfLetters;
        Fruit fruit = Fruit.APPLE;
        switch (fruit) {
            case PEAR:
                numberOfLetters = 4;
                break;
            case APPLE:
            case GRAPE:
            case MANGO:
                numberOfLetters = 5;
                break;
            case ORANGE:
            case PAPAYA:
                numberOfLetters = 6;
                break;
            default:
                throw new IllegalStateException("No Such Fruit:" + fruit);
        }
        System.out.println(numberOfLetters);

    }
}
enum Fruit {
    PEAR, APPLE, GRAPE, MANGO, ORANGE, PAPAYA;
}
```

如果有编码经验，你一定知道，switch 语句如果漏写了一个 break，那么逻辑往往就跑偏了，这种方式既繁琐，又容易出错。如果换成 switch 表达式，Pattern Matching 机制能够自然地保证只有单一路径会被执行：

Java 12

```java
/**
 * @author shkstart
 * @create 2019 下午 10:38
 */
public class SwitchTest1 {
    public static void main(String[] args) {
        Fruit fruit = Fruit.GRAPE;
        switch(fruit){
            case PEAR -> System.out.println(4);
            case APPLE,MANGO,GRAPE -> System.out.println(5);
            case ORANGE,PAPAYA -> System.out.println(6);
            default -> throw new IllegalStateException("No Such Fruit:" + fruit);
        };
    }
}
```

更进一步，下面的表达式，为我们提供了优雅地表达特定场合计算逻辑的方式：

```java
/**
 * @author shkstart
 * @create 2019 下午 10:44
 */
public class SwitchTest2 {
    public static void main(String[] args) {
        Fruit fruit = Fruit.GRAPE;
        int numberOfLetters = switch(fruit){
            case PEAR -> 4;
            case APPLE,MANGO,GRAPE -> 5;
            case ORANGE,PAPAYA -> 6;
            default -> throw new IllegalStateException("No Such Fruit:" + fruit);
        };
        System.out.println(numberOfLetters);
    }
}
```

举例2：

Java 12之前：

```java
public class SwitchTest {

	public static void main(String[] args) {
		Week day = Week.FRIDAY;
		switch (day) {
		case MONDAY:
		case FRIDAY:
		case SUNDAY:
			System.out.println(6);
			break;
		case TUESDAY:
			System.out.println(7);
			break;
		case THURSDAY:
		case SATURDAY:
			System.out.println(8);
			break;
		case WEDNESDAY:
			System.out.println(9);
			break;
        default:
            throw new IllegalStateException("What day is today?" + day);
		}
	}
}

enum Week {
	MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
}
```

Java 12：

```java
/**
 * @author shkstart
 * @create 2019 下午 11:06
 */
public class SwitchTest1 {

	public static void main(String[] args) {
		Week day = Week.FRIDAY;
		switch (day) {        
		case MONDAY,FRIDAY, SUNDAY -> System.out.println(6);        
		case TUESDAY -> System.out.println(7);
		case THURSDAY, SATURDAY -> System.out.println(8);        
		case WEDNESDAY -> System.out.println(9);
       	default -> throw new IllegalStateException("What day is today?" + day);
		}
	}
}

```

Java 12中更进一步：

```java
/**
 * @author shkstart
 * @create 2019 下午 11:06
 */
public class SwitchTest2 {
    public static void main(String[] args) {
        Week day = Week.FRIDAY;
        int numLetters = switch (day) {
            case MONDAY, FRIDAY, SUNDAY -> 6;
            case TUESDAY -> 7;
            case THURSDAY, SATURDAY -> 8;
            case WEDNESDAY -> 9;
            default -> throw new IllegalStateException("What day is today?" + day);
        };
    }
}
```



5.使用总结

这个语法如果做过Android开发的不会陌生，因为Kotlin 家的 when 表达式就是这么干的！

Switch Expressions 或者说起相关的 Pattern Matching 特性，为我们勾勒出了 Java 语法进化的一个趋势，将开发者从复杂繁琐的低层次抽象中逐渐解放出来，以更高层次更优雅的抽象，既降低代码量，又避免意外编程错误的出现，进而提高代码质量和开发效率。

6.展望

Java 11 以及之前版本中，Switch 表达式支持下面类型： byte、char、short、int、Byte、Character、Short、Integer、enum、String，在未来的某个 Java 版本有可能会允许支持 float、double 和 long （以及对应类型的包装类型）。

**JDK13中二次预览特性：**

在JDK 12中引入了Switch表达式作为预览特性。JDK 13提出了第二个switch表达式预览。JEP 354修改了这个特性，它引入了yield语句，用于返回值。这意味着，switch表达式(返回值)应该使用yield, switch语句(不返回值)应该使用break。

在 JDK 12中有一个，但是要进行一个更改：要从 switch 表达式中生成一个值 break，要删除with value语句以支持a  yield 声明。目的是扩展，switch 以便它可以用作语句或表达式，因此两个表单既可以使用 case ... : 带有连贯符号的传统标签，也可以使用新 case … -> 标签，而不需要通过，还有一个新的语句用于从 switch 表达式中产生值。这些更改将简化编码并为[模式匹配](https://openjdk.java.net/jeps/305)做好准备。 

在以前，我们想要在switch中返回内容，还是比较麻烦的，一般语法如下：

```java
	@Test
	public void testSwitch1(){
        String x = "3";
        int i;
        switch (x) {
            case "1":
                i=1;
                break;
            case "2":
                i=2;
                break;
            default:
                i = x.length();
                break;
        }
        System.out.println(i);
    }
```

在JDK13中使用以下语法：

```java
	@Test
    public void testSwitch2(){
        String x = "3";
        int i = switch (x) {
            case "1" -> 1;
            case "2" -> 2;
            default -> {
                yield 3;
            }
        };
        System.out.println(i);
    }
```

或者

```java
	@Test
    public void testSwitch3() {
        String x = "3";
        int i = switch (x) {
            case "1":
                yield 1;
            case "2":
                yield 2;
            default:
                yield 3;
        };
        System.out.println(i);
    }
```

在这之后，switch中就多了一个关键字用于跳出switch块了，那就是yield，他用于返回一个值。和return的区别在于：return会直接跳出当前循环或者方法，而yield只会跳出当前switch块。

**JDK14中转正特性：**

这是JDK 12和JDK 13中的预览特性，现在是正式特性了。

该特性规定，switch可以当作语句使用，也可以当作表达式使用。

这可以简化日常的编码方式，也为本版本中预览的模式匹配（JEP 305）特性打下了基础。

具体情况：使用->来替代以前的:+break；另外还提供了yield来在block中返回值

```java
/**
 *  switch的新特性
 *
 * @author shkstart Email:shkstart@126.com
 * @create 下午 12:10
 */
public class Feature04 {
    //jdk12之前的用法
    @Test
    public void test1() {

        Week day = Week.FRIDAY;
        switch (day) {
            case MONDAY:
            case TUESDAY:
            case WEDNESDAY:
                System.out.println(1);
                break;
            case THURSDAY:
                System.out.println(2);
                break;
            case FRIDAY:
            case SATURDAY:
                System.out.println(3);
                break;
            case SUNDAY:
                System.out.println(4);
                break;
            default:
                throw new IllegalStateException("What day is today?" + day);
        }

    }

    //jdk12新特性：引用switch表达式
    @Test
    public void test2(){

        Week day = Week.FRIDAY;
        switch (day){
            case MONDAY,TUESDAY,WEDNESDAY -> System.out.println(1);
            case THURSDAY -> System.out.println(2);
            case FRIDAY,SATURDAY -> System.out.println(3);
            case SUNDAY -> System.out.println(4);
            default -> throw new IllegalStateException("What day is today?" + day);
        }

        //使用变量接收switch表达式的值
        int num = switch (day) {
            case MONDAY, TUESDAY, WEDNESDAY -> 1;
            case THURSDAY -> 2;
            case FRIDAY, SATURDAY -> 3;
            case SUNDAY -> 4;
            default -> throw new IllegalStateException("What day is today?" + day);
        };

        System.out.println(num);

    }

    //jdk13新特性：引用了yield关键字，用于返回指定的数据，结束switch结构
    @Test
    public void test3(){
        String x = "3";
        int num = switch (x){
            case "1" -> 1;
            case "2" -> 2;
            case "3" -> 3;
            default -> {
                System.out.println("default...");
                yield 4;
            }
        };

        System.out.println(x);
    }

    @Test
    public void test4(){
        String x = "3";
        int num = switch (x){
            case "1":yield 1;
            case "2":yield 2;
            case "3":yield 3;
            default: yield 4;
        };
        System.out.println(num);
    }


}

enum Week {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
}
```



`18. switch的模式匹配`

**JDK17的预览特性：**

老代码写法：

```java
static String formatter(Object o) {
    String formatted = "unknown";
    if (o instanceof Integer i) {
        formatted = String.format("int %d", i);
    } else if (o instanceof Long l) {
        formatted = String.format("long %d", l);
    } else if (o instanceof Double d) {
        formatted = String.format("double %f", d);
    } else if (o instanceof String s) {
        formatted = String.format("String %s", s);
    }
    return formatted;
}
```

模式匹配新写法：

```java
static String formatterPatternSwitch(Object o) {
    return switch (o) {
        case Integer i -> String.format("int %d", i);
        case Long l    -> String.format("long %d", l);
        case Double d  -> String.format("double %f", d);
        case String s  -> String.format("String %s", s);
        default        -> o.toString();
    };
}
```

直接在 switch 上支持 Object 类型，这就等于同时支持多种类型，使用模式匹配得到具体类型，大大简化了语法量，这个功能还是挺实用的。

### 6.5 文本块

**JDK13中：**

现实问题

在Java中，通常需要使用String类型表达HTML，XML，SQL或JSON等格式的字符串，在进行字符串赋值时需要进行转义和连接操作，然后才能编译该代码，这种表达方式难以阅读并且难以维护。

文本块就是指多行字符串，例如一段格式化后的xml、json等。而有了文本块以后，用户不需要转义，Java能自动搞定。因此，文本块将提高Java程序的可读性和可写性。

目标

- 简化跨越多行的字符串，避免对换行等特殊字符进行转义，简化编写Java程序。
- 增强Java程序中字符串的可读性。

举例

会被自动转义，如有一段以下字符串：

```
<html>
  <body>
      <p>Hello, 尚硅谷</p>
  </body>
</html>
```

将其复制到Java的字符串中，会展示成以下内容：

```
"<html>\n" +
"    <body>\n" +
"        <p>Hello, 尚硅谷</p>\n" +
"    </body>\n" +
"</html>\n";
```

即被自动进行了转义，这样的字符串看起来不是很直观，在JDK 13中，就可以使用以下语法了：

```
"""
<html>
  <body>
      <p>Hello, world</p>
  </body>
</html>
""";
```

使用“”“作为文本块的开始符和结束符，在其中就可以放置多行的字符串，不需要进行任何转义。看起来就十分清爽了。

如常见的SQL语句：

```sql
select employee_id,last_name,salary,department_id
from employees
where department_id in (40,50,60)
order by department_id asc
```

原有方式：

```
String query = "select employee_id,last_name,salary,department_id\n" +
                "from employees\n" +
                "where department_id in (40,50,60)\n" +
                "order by department_id asc";
```

使用新特性：

```
String newQuery = """
        select employee_id,last_name,salary,department_id
        from employees
        where department_id in (40,50,60)
        order by department_id asc
""";
```



具体使用

1.基本使用

- 文本块是Java语言中的一种新文字。它可以用来表示任何字符串，并且提供更大的表现力和更少的复杂性。

- 文本块由零个或多个字符组成，由开始和结束分隔符括起来。
  - 开始分隔符是由三个双引号字符（"""），后面可以跟零个或多个空格，最终以行终止符结束。文本块内容以开始分隔符的行终止符后的第一个字符开始。
  - 结束分隔符也是由三个双引号字符（"""）表示，文本块内容以结束分隔符的第一个双引号之前的最后一个字符结束。

- 文本块中的内容可以直接使用"，"，但不是必需的。

- 文本块中的内容可以直接包括行终止符。允许在文本块中使用 \n，但不是必需的。例如，文本块：

```
"""
line1
line2
line3
"""
```

相当于：

```
"line1\nline2\nline3\n"
```

或者一个连接的字符串：

```
"line1\n" +
"line2\n" +
"line3\n"
```

如果字符串末尾不需要行终止符，则结束分隔符可以放在最后一行内容上。例如：

```
"""
line1
line2
line3"""
```

相当于

```
"line1\nline2\nline3"
```

文本块可以表示空字符串，但不建议这样做，因为它需要两行源代码：

```
String empty = """
""";
```

以下示例是错误格式的文本块：

```
String a = """""";   // 开始分隔符后没有行终止符
String b = """ """;  // 开始分隔符后没有行终止符
String c = """
           ";        // 没有结束分隔符
String d = """
           abc \ def
           """;      // 含有未转义的反斜线（请参阅下面的转义处理）
```

在运行时，文本块将被实例化为String的实例，就像字符串一样。从文本块派生的String实例与从字符串派生的实例是无法区分的。具有相同内容的两个文本块将引用相同的String实例，就像字符串一样。

此外，

2. 编译器在编译时会删除掉这些多余的空格。

下面这段代码中，我们用.来表示我们代码中的的空格，而这些位置的空格就是多余的。

```
String html = """
..............<html>
..............    <body>
..............        <p>Hello, world</p>
..............    </body>
..............</html>
..............""";
```

多余的空格还会出现在每一行的结尾，特别是当你从其他地方复制过来时，更容易出现这种情况，比如下面的代码：

```
String html = """
..............<html>...
..............    <body>
..............        <p>Hello, world</p>....
..............    </body>.
..............</html>...
..............""";
```

这些多余的空格对于程序员来说是看不到的，但是他又是实际存在的，所以如果编译器不做处理，可能会导致程序员看到的两个文本块内容是一样的，但是这两个文本块却因为存在这种多余的空格而导致差异，比如哈希值不相等。

3. 转义字符

允许开发人员使用 \n，\f 和\r 来进行字符串的垂直格式化，使用 \b和 \t进行水平格式化。比如下面的代码是合法的：

```java
String html = """
              <html>\n
                  <body>\n
                      <p>Hello, world</p>\n
                  </body>\n
              </html>\n
              """;
```

请注意，在文本块内自由使用"是合法的。例如:

```
String story = """
    "When I use a word," Humpty Dumpty said,
    in rather a scornful tone, "it means just what I
    choose it to mean - neither more nor less."
    "The question is," said Alice, "whether you
    can make words mean so many different things."
    "The question is," said Humpty Dumpty,
    "which is to be master - that's all."
""";
```

但是，三个"字符的序列需要进行转义至少一个"以避免模仿结束分隔符：

```java
String code = 
    """
    String text = \"""
        A text block inside a text block
    \""";
    """;
```

4. 文本块连接

可以在任何可以使用字符串的地方使用文本块。例如，文本块和字符串可以相互连接：

```
String code = "public void print(Object o) {" +
              """
                  System.out.println(Objects.toString(o));
              }
              """;
```

但是，涉及文本块的连接可能变得相当笨重。以下面文本块为基础：

```
String code = """
              public void print(Object o) {
                  System.out.println(Objects.toString(o));
              }
              """;
```

假设我们想把上面的Object改为来自某一变量，我们可能会这么写：

```
String code = """
              public void print(""" + type + """
               o) {
                  System.out.println(Objects.toString(o));
              }
              """;
```

可以发现这种写法可读性是非常差的，更简洁的替代方法是使用String :: replace或String :: format，比如：

```
String code = """
              public void print($type o) {
                  System.out.println(Objects.toString(o));
              }
              """.replace("$type", type);
```

```
String code = String.format("""
              public void print(%s o) {
                  System.out.println(Objects.toString(o));
              }
              """, type);
```

另一个方法是使用String :: formatted，这是一个新方法，比如：

```
String source = """
                public void print(%s object) {
                    System.out.println(Objects.toString(object));
                }
                """.formatted(type);
```

**JDK14中：**

JDK13引入的text blocks进行第二轮preview，JDK14的版本主要增加了两个escape sequences，分别是` \ <line-terminator>`与`\s  escape sequence`

现实问题：

- 在Java中，通常需要使用String类型表达HTML，XML，SQL或JSON等格式的字符串，在进行字符串赋值时需要进行转义和连接操作，然后才能编译该代码，这种表达方式难以阅读并且难以维护。

目标 

- 简化跨越多行的字符串，避免对换行等特殊字符进行转义，简化编写Java程序。
- 增强Java程序中用字符串表示的其他语言的代码的可读性
- 解析新的转义序列

举例：

```java
/**
 * 文本块(text blocks)的使用
 *
 * @author shkstart Email:shkstart@126.com
 * @create 下午 7:13
 */
public class Feature05 {


    @Test
    public void test1(){
        String text1 = "The Sound of silence\n" +
                "Hello darkness, my old friend\n" +
                "I've come to talk with you again\n" +
                "Because a vision softly creeping\n" +
                "Left its seeds while I was sleeping\n" +
                "And the vision that was planted in my brain\n" +
                "Still remains\n" +
                "Within the sound of silence";

        System.out.println(text1);

        //jdk13中的新特性：
        String text2 = """
                The Sound of silence
                Hello darkness, my old friend
                I've come to talk with you again
                Because a vision softly creeping
                Left its seeds while I was sleeping
                And the vision that was planted in my brain
                Still remains
                Within the sound of silence
                """;
        System.out.println();
        System.out.println(text2);

        System.out.println(text1.length());
        System.out.println(text2.length());
    }

    //html
    @Test
    public void test2(){
        String html1 = "<html lang=\"en\">\n" +
                "<head>\n" +
                "    <meta charset=\"UTF-8\">\n" +
                "    <title>java14新特性</title>\n" +
                "</head>\n" +
                "<body>\n" +
                "    <p>hello,atguigu</p>\n" +
                "</body>\n" +
                "</html>";
        //jdk13中的新特性：
        String html2 = """
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>java14新特性</title>
                </head>
                <body>
                    <p>hello,atguigu</p>
                </body>
                </html>
                """;
    }

    //json
    @Test
    public void test3() {
        //jdk13之前的写法
        String myJson = "{\n" +
                "    \"name\":\"Song Hongkang\",\n" +
                "     \"address\":\"www.atguigu.com\",\n" +
                "    \"email\":\"shkstart@126.com\"\n" +
                "}";
        System.out.println(myJson);

        //jdk13的新特性
        String myJson1 = """
                {
                    "name":"Song Hongkang",
                     "address":"www.atguigu.com",
                    "email":"shkstart@126.com"
                }""";
        System.out.println(myJson1);
    }

    //sql
    @Test
    public void test4(){
        String sql = "SELECT id,NAME,email\n" +
                "FROM customers\n" +
                "WHERE id > 4\n" +
                "ORDER BY email DESC";

        //jdk13新特性：
        String sql1 = """
                SELECT id,NAME,email
                FROM customers
                WHERE id > 4
                ORDER BY email DESC
                """;



    }
    //jdk14新特性
    @Test
    public void test5(){
        String sql1 = """
                SELECT id,NAME,email
                FROM customers
                WHERE id > 4
                ORDER BY email DESC
                """;
        System.out.println(sql1);

        // \:取消换行操作
        // \s:表示一个空格
        String sql2 = """
                SELECT id,NAME,email \
                FROM customers\s\
                WHERE id > 4 \
                ORDER BY email DESC
                """;
        System.out.println(sql2);
    }
}
```

**JDK15中：文本块功能转正**

Text Blocks首次是在JDK 13中以预览功能出现的，然后在JDK 14中又预览了一次，终于在JDK 15中被确定下来，可放心使用了。

文本块是一种多行字符串文字，它避免了大多数转义序列的需要，以一种可预测的方式自动设置字符串的格式，并在需要时使开发人员可以控制格式，简化编写 Java 程序的任务。

文本块建议的目标是提高 Java 程序中的字符串的可读性，这些字符串表示以非 Java 语言编写的代码。
另一个目标是支持从字符串文本迁移，规定任何新构造都可以表达与字符串文本相同的字符串集，解释相同的转义序列，并且以与字符串文本相同的方式进行操作。OpenJDK 开发人员希望添加转义序列来管理显式空白和换行控件。

### 6.6 instanceof的模式匹配

**JDK14中预览特性：**

这个特性很有意思，因为它为更为通用的模式匹配打开了大门。模式匹配通过更为简便的语法基于一定的条件来抽取对象的组件，而 instanceof 刚好是这种情况，它先检查对象类型，然后再调用对象的方法或访问对象的字段。

有了该功能，可以减少Java程序中显式强制转换的数量，从而提高生产力，还能实现更精确、简洁的类型安全的代码。

Java 14之前：

 ![image-20220528211139501](images/image-20220528211139501.png)

Java 14新特性：

 ![image-20220528211202435](images/image-20220528211202435.png)

举例：

```java
/**
 * 1. JEP 305：instanceof的模式匹配（预览）
 *
 * @author shkstart Email:shkstart@126.com
 * @create 上午 11:32
 */
public class Feature01 {
    @Test
    public void test1(){

        Object obj = new String("hello,Java14");
        obj = null;//在使用null 匹配instanceof 时，返回都是false.
        if(obj instanceof String){
            String str = (String) obj;
            System.out.println(str.contains("Java"));
        }else{
            System.out.println("非String类型");
        }

        //举例1：
        if(obj instanceof String str){ //新特性：省去了强制类型转换的过程
            System.out.println(str.contains("Java"));
        }else{
            System.out.println("非String类型");
        }
    }
}

// 举例2
class InstanceOf{

    String str = "abc";

    public void test(Object obj){

        if(obj instanceof String str){//此时的str的作用域仅限于if结构内。
            System.out.println(str.toUpperCase());
        }else{
            System.out.println(str.toLowerCase());
        }

    }

}

//举例3：
class Monitor{
    private String model;
    private double price;

//    public boolean equals(Object o){
//        if(o instanceof Monitor other){
//            if(model.equals(other.model) && price == other.price){
//                return true;
//            }
//        }
//        return false;
//    }


    public boolean equals(Object o){
        return o instanceof Monitor other && model.equals(other.model) && price == other.price;
    }

}
```

**JDK15中第二次预览：**

在Java 14中作为预览语言功能引入的instanceof模式匹配，在Java 15中处于第二次预览，而没有任何更改。

模式匹配允许程序中的通用逻辑（主要是从对象中的条件提取组件）可以更简洁地表达。Haskell 和 C# 等语言已采用模式匹配来实现简洁和安全性。

旧写法：

```java
// 先判断类型
if (obj instanceof String) {
    // 然后转换
    String s = (String) obj;
    // 然后才能使用
}
```

新写法：（自动匹配模式）

```java
if (obj instanceof String s) {
    // 如果类型匹配 直接使用
} else {
    // 如果类型不匹配则不能直接使用
}
```

**JDK16中转正特性：**

java的Instanceof模式匹配最初是在java14中引入的，在15中得到增强，现在在java16中转正。

### 6.7 Record

**JDK14中预览特性：**

**背景**

早在2019年2月份，Java 语言架构师 Brian Goetz，曾经写过一篇文章，详尽的说明了并吐槽了Java语言，他和很多程序员一样抱怨“Java太啰嗦”或有太多的“繁文缛节”，他提到：开发人员想要创建纯数据载体类（plain data carriers）通常都必须编写大量低价值、重复的、容易出错的代码。如：构造函数、getter/setter、equals()、hashCode()以及toString()等。

以至于很多人选择使用IDE的功能来自动生成这些代码。还有一些开发会选择使用一些第三方类库，如Lombok等来生成这些方法，从而会导致了令人吃惊的表现（surprising behavior）和糟糕的可调试性（poor debuggability）。

**神说要用record，于是就有了**

我们有时候需要编写许多低价值的重复代码来实现一个简单的数据载体类：构造函数，访问器，equals()，hashCode () ，toString ()等。为了避免这种重复代码，Java 14推出record。

Java14也许最令人兴奋，同时也是最令人惊讶的创新就是：Record类型的引入 。

使用record来减少类声明语法，效果类似 lombok 的 @Data 注解，Kotlin中的data class。它们的共同点是类的部分或全部状态可以直接在类头中描述，并且这个类中只包含了纯数据而已。

该预览特性提供了一种更为紧凑的语法来声明类。值得一提的是，该特性可以大幅减少定义类似数据类型时所需的样板代码。

- 当你用**record** 声明一个类时，该类将自动拥有以下功能：
  - 获取成员变量的简单方法，以上面代码为例 name() 和 partner() 。注意区别于我们平常getter的写法。
  - 一个 equals 方法的实现，执行比较时会比较该类的所有成员属性
  - 重写 equals 当然要重写 hashCode
  - 一个可以打印该类所有成员属性的 toString 方法。
  - 请注意只会有一个构造方法。

- 和枚举类型一样，记录也是类的一种受限形式。作为回报，记录对象在简洁性方面提供了显著的好处。
  - Enum  interface 

- 还可以在Record声明的类中定义静态字段、静态方法、构造器或实例方法。

- 不能在Record声明的类中定义实例字段；类不能声明为abstract；不能声明显式的父类等。

- 为了在Java 14中引入这种新类型，需要在Java.lang.Class对象中添加如下两个新方法：

  - RecordComponent[] getRecordComponents()

  - boolean isRecord()

举例：

```java
/**
 *  Record类型的演示
 *
 * @author shkstart Email:shkstart@126.com
 * @create 下午 6:13
 */
public class Feature03 {
    @Test
    public void test1(){
        //测试构造器
        Person p1 = new Person("罗密欧",new Person("zhuliye",null));
        //测试toString()
        System.out.println(p1);
        //测试equals():
        Person p2 = new Person("罗密欧",new Person("zhuliye",null));
        System.out.println(p1.equals(p2));

        //测试hashCode()和equals()
        HashSet<Person> set = new HashSet<>();
        set.add(p1);
        set.add(p2);

        for (Person person : set) {
            System.out.println(person);
        }

        //测试name()和partner():类似于getName()和getPartner()
        System.out.println(p1.name());
        System.out.println(p1.partner());

    }

    @Test
    public void test2(){
        Person p1 = new Person("zhuyingtai");

        System.out.println(p1.getNameInUpperCase());

        Person.nation = "CHN";
        System.out.println(Person.showNation());

    }
}
```

```java
/**
 * @author shkstart Email:shkstart@126.com
 * @create 下午 6:20
 */
public record Person(String name,Person partner) {

    //还可以声明静态的属性、静态的方法、构造器、实例方法

    public static String nation;

    public static String showNation(){
        return nation;
    }

    public Person(String name){
        this(name,null);
    }

    public String getNameInUpperCase(){
        return name.toUpperCase();
    }
    //不可以声明非静态的属性
//    private int id;//报错
}

//不可以将record定义的类声明为abstract的
//abstract record Order(){
//
//}

//不可以给record定义的类声明显式的父类（非Record类）
//record Order() extends Thread{
//
//}
```

**JDK15中第二次预览特性：**

Records Class 也是第二次出现的预览功能，它在 JDK 14 中也出现过一次了，使用 Record 可以更方便的创建一个常量类，使用的前后代码对比如下。

当你用Record 声明一个类时，该类将自动拥有以下功能：

- 获取成员变量的简单方法，以上面代码为例 name() 和 partner() 。注意区别于我们平常getter的写法。
- 一个 equals 方法的实现，执行比较时会比较该类的所有成员属性
- 重写 equals 当然要重写 hashCode
- 一个可以打印该类所有成员属性的 toString 方法。
- 请注意只会有一个构造方法。

旧写法：

```java
class Point {
    private final int x;
    private final int y;
    Point(int x, int y) { 
        this.x = x;
        this.y = y;
    }
    int x() { return x; }
    int y() { return y; }
    public boolean equals(Object o) { 
        if (!(o instanceof Point)) return false;
        Point other = (Point) o;        return other.x == x && other.y = y;
    }    public int hashCode() {
        return Objects.hash(x, y);
    }    public String toString() { 
        return String.format("Point[x=%d, y=%d]", x, y);
    }
}
```

新写法：

```java
record Point(int x, int y) { }
```

**JDK16中转正特性：**

此特性在JDK14中作为预览版本引入，最终到JDK16中转正。

`record` 是一种全新的类型，它本质上是一个 `final` 类，同时所有的属性都是 `final` 修饰，它会自动编译出 `public get` `hashcode` 、`equals`、`toString` 等方法，减少了代码编写量。

```java
public record Dog(String name, Integer age) {
}
```

```java
public class Java14Record {

    public static void main(String[] args) {
        Dog dog1 = new Dog("牧羊犬", 1);
        Dog dog2 = new Dog("田园犬", 2);
        Dog dog3 = new Dog("哈士奇", 3);
        System.out.println(dog1);
        System.out.println(dog2);
        System.out.println(dog3);
    }
}
```



**怎样看待记录**

你应该如何看待和处理这些新的语言元素呢？记录是一种新的、受限形式的类，用于将数据建模为数据。我们不可能向记录添加任何附加状态；除了记录的组件之外，你不能定义（非静态）字段。记录实际上是建模不可变数据的。你也可以将记录视为元组，但它并不只是其他一些语言所有的那种一般意义上的元组，在那种元组里有一些可以由索引引用的任意组件。在 Java 中，元组元素有实际名称，并且元组类型本身——即记录，也有一个名称，因为名称在 Java 中很重要。

**记录不适合哪些场景**

有些场景中我们可能会觉得记录用起来并不是很合适。首先，它们并不是任何现有代码的一个样板缩减机制。虽然我们现在有一种非常简洁的方式来定义这些记录，但这并不意味着你的应用程序中的任何数据（如类）都可以轻松地被记录替换，这主要是因为记录存在的一些限制所致。这也不是它真正的设计目标。

记录的设计目标是提供一种将数据建模为数据的好方法。它也不是 JavaBeans 的直接替代品，因为正如我之前提到的，访问器这样的方法不符合 JavaBeans 的 get 标准。另外 JavaBeans 通常是可变的，而记录是不可变的。尽管它们的用途有点像，但记录并不会以某种方式取代 JavaBean。你也不应该将记录视为值类型。

值类型可能会在未来的 Java 版本中作为语言增强引入，其主要关注内存布局和类中数据的有效表示。当然，这两条世界线在未来某一时刻可能会合并在一起，但就目前而言，记录只是表达纯数据类的一种更简洁的方式。

其他内容见：https://www.cnblogs.com/chengxuyuan-blog/p/15232243.html



### 6.8 密封类

**JDK15的预览特性：**

通过密封的类和接口来增强 Java 编程语言，这是新的预览特性。
用于限制超类的使用，密封的类和接口限制其它可能继承或实现它们的其它类或接口。

这个特性的目标包括——允许类或接口的开发者来控制哪些代码负责实现，提供了比限制使用超类的访问修饰符声明方式更多选择,并通过支持对模式的详尽分析而支持模式匹配的未来发展。

在Java中，类层次结构通过继承实现代码的重用，父类的方法可以被许多子类继承。
但是，类层次结构的目的并不总是重用代码。有时，其目的是对域中存在的各种可能性进行建模，例如图形库支持的形状类型或金融应用程序支持的贷款类型。当以这种方式使用类层次结构时，我们可能需要限制子类集从而来简化建模。

具体使用：
因为我们引入了sealed class或interfaces，这些class或者interfaces只允许被指定的类或者interface进行扩展和实现。

使用修饰符sealed，您可以将一个类声明为密封类。密封的类使用reserved关键字permits列出可以直接扩展它的类。子类可以是最终的，非密封的或密封的。

示例：

```java
package com.atguigu.java;

public abstract sealed class Shape permits Circle, Rectangle, Square {...}
public final class Circle extends Shape {...}
public sealed class Rectangle extends Shape permits TransparentRectangle, FilledRectangle {...}
public final class TransparentRectangle extends Rectangle {...}
public final class FilledRectangle extends Rectangle {...}
public non-sealed class Square extends Shape {...}
```

**JDK16二次预览特性：**

通过密封类和接口，Java编程语言得到了增强。它限制哪些类或接口可以限制或实现它们。

Sealed Classes是在JDK15中引入的概念，它表示某个类允许哪些类来继承它：

```java
public sealed class SealExample permits Seal1, Seal2{}
    
public non-sealed class Seal1 extends SealExample {}

public final class Seal2 extends SealExample {}
```

final表示Seal2不能再被继承了。non-sealed 表示可以允许任何类继承。

#########

下面是一段引用：

我们都知道，在 Java 中如果想让一个类不能被继承和修改，这时我们应该使用 `final` 关键字对类进行修饰。不过这种要么可以继承，要么不能继承的机制不够灵活，有些时候我们可能想让某个类可以被某些类型继承，但是又不能随意继承，是做不到的。Java 15 尝试解决这个问题，引入了 `sealed` 类，被 `sealed` 修饰的类可以指定子类。这样这个类就只能被指定的类继承。

而且 `sealed` 修饰的类的机制具有传递性，它的子类必须使用指定的关键字进行修饰，且只能是 `final`、`sealed`、`non-sealed` 三者之一。

############

下面来谈谈密封类（sealed class）这个特性。请注意，这是 Java 16 中的预览特性，将在 Java 17 中成为最终版本。你需要将--enable-preview 标志传递给编译器调用和 JVM 调用才能在 Java 16 中使用这个特性。该特性允许你控制继承层次结构。

假设你想对一个超类型 Option 建模，其中你只想有 Some 和 Empty 两个子类型。并且你想预防 Option 类型获得任何扩展。例如，你不想在层次结构中允许 Maybe 类型。

![image-20220529122908337](images/image-20220529122908337.png)

因此，你已经详细描述了 Option 类型的所有子类型。如你所知，目前在 Java 中控制继承的唯一工具是通过 final 关键字。这意味着根本不能有任何子类，但这不是我们想要的。有一些解决方法可以在没有密封类的情况下建模这个特性，但有了密封类后就容易多了。

密封类特性带有新的关键字 sealed 和 permits。看看下面的代码段。

```java
public sealed class Option<T>
 permits Some, Empty {
 ...
}
public final class Some
 extends Option<String> {
 ...
}
public final class Empty
 extends Option<Void> {
 ...
}
```

我们可以定义要 sealed 的 Option 类。然后，在类声明之后，我们使用 permit 关键字来规定只允许 Some 和 Empty 类扩展 Option 类。然后，我们可以像往常一样将 Some 和 Empty 定义为类。我们希望将这些子类设为 final，以防止进一步继承。现在系统就不能编译其他类来扩展 Option 类了，这是由编译器通过密封类机制强制执行的。

**JDK17转正特性：**

密封类（Sealed Classes）是 Java 15 引入的， Java 17 正式转正。

密封类可以对继承或者实现它们的类进行限制。

密封类可以用来增强 Java 编程语言，防止其他类或接口扩展或实现它们。

比如抽象类 `Person` 只允许 `Employee` 和 `Manager` 继承。

```java
public abstract sealed class Person
    permits Employee, Manager {

    //...
}
```

另外，任何扩展密封类的类本身都必须声明为 `sealed`、`non-sealed` 或 `final`。

```java
public final class Employee extends Person {
}

public non-sealed class Manager extends Person {
}
```

再举例：

```java
public abstract sealed class Student
    permits ZhangSan, LiSi, ZhaoLiu {
    ...
        
}
```

类 Student 被 `sealed` 修饰，说明它是一个密封类，并且只允许指定的 3 个子类继承。

再举例：

```java
package com.example.geometry;

public abstract sealed class Shape
    permits Circle, Rectangle, Square, WeirdShape { ... }

public final class Circle extends Shape { ... }

public sealed class Rectangle extends Shape 
    permits TransparentRectangle, FilledRectangle { ... }
public final class TransparentRectangle extends Rectangle { ... }
public final class FilledRectangle extends Rectangle { ... }

public final class Square extends Shape { ... }

public non-sealed class WeirdShape extends Shape { ... }
```



### 6.9 隐藏类

**JDK15新特性：**

该提案通过启用标准 API 来定义无法发现且具有有限生命周期的隐藏类，从而提高 JVM 上所有语言的效率。JDK内部和外部的框架将能够动态生成类，而这些类可以定义隐藏类。通常来说基于JVM的很多语言都有动态生成类的机制，这样可以提高语言的灵活性和效率。
隐藏类天生为框架设计的，在运行时生成内部的class。
隐藏类只能通过反射访问，不能直接被其他类的字节码访问。
隐藏类可以独立于其他类加载、卸载，这可以减少框架的内存占用。

Hidden Classes是什么呢？
Hidden Classes就是不能直接被其他class的二进制代码使用的class。Hidden Classes主要被一些框架用来生成运行时类，但是这些类不是被用来直接使用的，而是通过反射机制来调用。
比如在JDK8中引入的lambda表达式，JVM并不会在编译的时候将lambda表达式转换成为专门的类，而是在运行时将相应的字节码动态生成相应的类对象。
另外使用动态代理也可以为某些类生成新的动态类。

那么我们希望这些动态生成的类需要具有什么特性呢？
不可发现性。因为我们是为某些静态的类动态生成的动态类，所以我们希望把这个动态生成的类看做是静态类的一部分。所以我们不希望除了该静态类之外的其他机制发现。
访问控制。我们希望在访问控制静态类的同时，也能控制到动态生成的类。
生命周期。动态生成类的生命周期一般都比较短，我们并不需要将其保存和静态类的生命周期一致。

API的支持
所以我们需要一些API来定义无法发现的且具有有限生命周期的隐藏类。这将提高所有基于JVM的语言实现的效率。
比如：
java.lang.reflect.Proxy可以定义隐藏类作为实现代理接口的代理类。
java.lang.invoke.StringConcatFactory可以生成隐藏类来保存常量连接方法；
java.lang.invoke.LambdaMetaFactory可以生成隐藏的nestmate类，以容纳访问封闭变量的lambda主体；

普通类是通过调用ClassLoader::defineClass创建的，而隐藏类是通过调用Lookup::defineHiddenClass创建的。这使JVM从提供的字节中派生一个隐藏类，链接该隐藏类，并返回提供对隐藏类的反射访问的查找对象。调用程序可以通过返回的查找对象来获取隐藏类的Class对象。

## 7. 新的API

### 7.1 Optional类

**这是JDK8的新特性**

**概述**

到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。

Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。

Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。

**方法**

Optional提供很多有用的方法，这样我们就不用显式进行空值检测。

- **创建Optional类对象的方法：**

  - static <T> Optional<T> empty() ：用来创建一个空的Optional实例
  - static <T> Optional<T> of(T value) ：用来创建一个Optional实例，value必须非空
  - `static <T> Optional<T> ofNullable(T value)` ：用来创建一个Optional实例，value可能是空，也可能非空

- **判断Optional容器中是否包含对象：**

  - boolean isPresent() : 判断Optional容器中的值是否存在
  - void ifPresent(Consumer<? super T> consumer) ：判断Optional容器中的值是否存在，如果存在，就对它进行Consumer指定的操作，如果不存在就不做

- **获取Optional容器的对象：**

  - T get(): 如果调用对象包含值，返回该值。否则抛异常。T get()与of(T value)配合使用

  - T orElse(T other) ：orElse(T other) 与ofNullable(T value)配合使用，

    如果Optional容器中非空，就返回所包装值，如果为空，就用orElse(T other)other指定的默认值（备胎）代替

  - T orElseGet(Supplier<? extends T> other) ：如果Optional容器中非空，就返回所包装值，如果为空，就用Supplier接口的Lambda表达式提供的值代替

  - T orElseThrow(Supplier<? extends X> exceptionSupplier) ：如果Optional容器中非空，就返回所包装值，如果为空，就抛出你指定的异常类型代替原来的NoSuchElementException

**举例**

```java
package com.atguigu.optional;

import java.util.Optional;

import org.junit.Test;

public class TestOptional {
    @Test
    public void test9(){
        String str = "Hello1";
        Optional<String> opt = Optional.ofNullable(str);
        //判断是否是纯字母单词，如果是，转为大写，否则保持不变
        String result = opt.filter(s->s.matches("[a-zA-Z]+"))
                .map(s -> s.toUpperCase()).orElse(str);
        System.out.println(result);
    }


    @Test
    public void test8(){
        String str = null;
        Optional<String> opt = Optional.ofNullable(str);
        String string = opt.orElseThrow(()->new RuntimeException("值不存在"));
        System.out.println(string);
    }


    @Test
    public void test7(){
        String str = null;
        Optional<String> opt = Optional.ofNullable(str);
        String string = opt.orElseGet(String::new);
        System.out.println(string);
    }

    @Test
    public void test6(){
        String str = "hello";
        Optional<String> opt = Optional.ofNullable(str);
        String string = opt.orElse("atguigu");
        System.out.println(string);
    }

    @Test
    public void test5(){
        String str = null;
        Optional<String> opt = Optional.ofNullable(str);
//		System.out.println(opt.get());//java.util.NoSuchElementException: No value present
    }

    @Test
    public void test4(){
        String str = "hello";
        Optional<String> opt = Optional.of(str);

        String string = opt.get();
        System.out.println(string);
    }


    @Test
    public void test3(){
        String str = null;
        Optional<String> opt = Optional.ofNullable(str);
        System.out.println(opt);
    }

    @Test
    public void test2(){
        Optional<String> opt = Optional.empty();
        System.out.println(opt);
    }

    @Test
    public void test1(){
        String str = "hello";
        Optional<String> opt = Optional.of(str);
        System.out.println(opt);
    }
}

```

**这是JDK9-11的新特性**

| **新增方法**                                                 | **描述**                                                     | **新增的版本** |
| ------------------------------------------------------------ | ------------------------------------------------------------ | -------------- |
| boolean isEmpty()                                            | 判断value是否为空                                            | JDK  11        |
| ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction) | value非空，执行参数1功能；如果value为空，执行参数2功能       | JDK  9         |
| Optional<T> or(Supplier<? extends Optional<? extends T>> supplier) | value非空，返回对应的Optional；value为空，返回形参封装的Optional | JDK  9         |
| Stream<T> stream()                                           | value非空，返回仅包含此value的Stream；否则，返回一个空的Stream | JDK  9         |
| T orElseThrow()                                              | value非空，返回value；否则抛异常NoSuchElementException       | JDK  10        |

### 7.2 String存储结构和API变更

**这是JDK9的新特性。**

产生背景：

> Motivation
> The current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.

使用说明：

> ## Description
>
> We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.

结论：String 再也不用 char[] 来存储啦，改成了 byte[] 加上编码标记，节约了一些空间。

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    @Stable
    private final byte[] value;
	...
}
```

拓展：StringBuffer 与 StringBuilder

那StringBuffer 和 StringBuilder 是否仍无动于衷呢？

> String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM's intrinsic string operations.

**JDK11新特性：新增了一系列字符串处理方法**

| **描述**             | **举例**                                        |
| -------------------- | ----------------------------------------------- |
| 判断字符串是否为空白 | "  ".isBlank(); // true                         |
| 去除首尾空白         | "  Javastack ".strip(); // "Javastack"          |
| 去除尾部空格         | "  Javastack ".stripTrailing(); // " Javastack" |
| 去除首部空格         | "  Javastack ".stripLeading(); // "Javastack "  |
| 复制字符串           | "Java".repeat(3);//  "JavaJavaJava"             |
| 行数统计             | "A\nB\nC".lines().count();  // 3                |

**JDK12新特性：String 实现了 Constable 接口**

String源码：

```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence,Constable, ConstantDesc {
```

java.lang.constant.Constable接口定义了抽象方法：

```java
public interface Constable {
	Optional<? extends ConstantDesc> describeConstable();
}
```

Java 12 String 的实现源码：

```java
@Override
public Optional<String> describeConstable() {
	return Optional.of(this);
}
```

很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型，Optional不懂的可以参考Java 8的新特性

6.3.2 String#describeConstable和resolveConstantDesc

一个非常有趣的方法来自新引入的接口java.lang.constant.Constable - 它用于标记constable类型，这意味着这类型的值是常量，可以在JVMS 4.4常量池中定义。

```http
Java SE > Java SE Specifications > Java Virtual Machine Specification下的第4章：
Chapter 4. The class File Format

https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html
```

String的源码：

```java
/**
 * Returns an {@link Optional} containing the nominal descriptor for this
 * instance, which is the instance itself.
 *
 * @return an {@link Optional} describing the {@linkplain String} instance
 * @since 12
 */
@Override
public Optional<String> describeConstable() {
 return Optional.of(this);
}


/**
 * Resolves this instance as a {@link ConstantDesc}, the result of which is
 * the instance itself.
 *
 * @param lookup ignored
 * @return the {@linkplain String} instance
 * @since 12
 */
@Override
public String resolveConstantDesc(MethodHandles.Lookup lookup) {
 return this;
}
```

举例：

```java
private static void testDescribeConstable() {
	System.out.println("======test java 12 describeConstable======");
	String name = "尚硅谷Java高级工程师";
	Optional<String> optional = name.describeConstable();
	System.out.println(optional.get());
}
```

结果输出：

```java
======test java 12 describeConstable======
尚硅谷Java高级工程师
```

**JDK12新特性：String新增方法**

1. String#transform(Function)

JDK-8203442引入的一个小方法，它提供的函数作为输入提供给特定的String实例，并返回该函数返回的输出。

```java
var result = "foo".transform(input -> input + " bar");
System.out.println(result); // foo bar
```

或者

```java
var result = "foo"
 .transform(input -> input + " bar")
 .transform(String::toUpperCase)
System.out.println(result); // FOO BAR
```

对应的源码：

```java
/**
* This method allows the application of a function to {@code this}
* string. The function should expect a single String argument
* and produce an {@code R} result.
* <p>
* Any exception thrown by {@code f()} will be propagated to the
* caller.
*
* @param f    functional interface to a apply
*
* @param <R>  class of the result
*
* @return     the result of applying the function to this string
*
* @see java.util.function.Function
*
* @since 12
*/
public <R> R transform(Function<? super String, ? extends R> f) {
 return f.apply(this);
}
```

传入一个函数式接口 Function，接受一个值，返回一个值，参考：Java 8 新特性之函数式接口。

在某种情况下，该方法应该被称为map()。

举例：

```java
private static void testTransform() {
	System.out.println("======test java 12 transform======");
	List<String> list1 = List.of("Java", " Python", " C++ ");
	List<String> list2 = new ArrayList<>();
	list1.forEach(element -> list2.add(element.transform(String::strip)
								  .transform(String::toUpperCase)
								  .transform((e) -> "Hi," + e))
				 );
	list2.forEach(System.out::println);
}
```

结果输出：

```java
======test java 12 transform======
Hi,JAVA
Hi,PYTHON
Hi,C++
```

示例是对一个字符串连续转换了三遍，代码很简单。如果使用Java 8的Stream特性，可以如下实现：

```java
private static void testTransform1() {
        System.out.println("======test before java 12 ======");
        List<String> list1 = List.of("Java  ", " Python", " C++ ");

        Stream<String> stringStream = list1.stream().map(element -> element.strip()).map(String::toUpperCase).map(element -> "Hello," + element);
        List<String> list2 = stringStream.collect(Collectors.toList());
        list2.forEach(System.out::println);
    }
```

2. String#indent

该方法允许我们调整String实例的缩进。

举例：

```java
private static void testIndent() {
	System.out.println("======test java 12 indent======");
	String result = "Java\n Python\nC++".indent(3);
	System.out.println(result);
}
```

结果输出：

```java
======test java 12 indent======
   Java
    Python
   C++
```

换行符 \n 后向前缩进 n 个空格，为 0 或负数不缩进。

以下是 indent 的核心源码：

```java
	/**
     * Adjusts the indentation of each line of this string based on the value of
     * {@code n}, and normalizes line termination characters.
     * <p>
     * This string is conceptually separated into lines using
     * {@link String#lines()}. Each line is then adjusted as described below
     * and then suffixed with a line feed {@code "\n"} (U+000A). The resulting
     * lines are then concatenated and returned.
	 *  ...略...
     *
     * @since 12
     */
    public String indent(int n) {
        if (isEmpty()) {
            return "";
        }
        Stream<String> stream = lines();
        if (n > 0) {
            final String spaces = " ".repeat(n);
            stream = stream.map(s -> spaces + s);
        } else if (n == Integer.MIN_VALUE) {
            stream = stream.map(s -> s.stripLeading());
        } else if (n < 0) {
            stream = stream.map(s -> s.substring(Math.min(-n, s.indexOfNonWhitespace())));
        }
        return stream.collect(Collectors.joining("\n", "", "\n"));
    }
```

其实就是调用了 lines() 方法来创建一个 Stream，然后再往前拼接指定数量的空格。

### 7.3 JDK11：InputStream 加强

InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。

```java
var classLoader = ClassLoader.getSystemClassLoader();
var inputStream = classLoader.getResourceAsStream("javastack.txt");
var javastack = File.createTempFile("javastack2", "txt");

try (var outputStream = new FileOutputStream(javastack)) {
  inputStream.transferTo(outputStream);
} 
```

### 7.4 JDK16：提供基于值的类的警告

这个是什么意思呢？我们知道java中对应的primary类型都有一个Object类型，比如int对应的是Integer。

如果是用Integer的构造函数，则我们可以这样构造：

```java
Integer integer= new Integer(100);
```

但是在JDK16中，这种构造函数已经被废弃了：

```java
@Deprecated(since="9", forRemoval = true)
public Integer(int value) {
	this.value = value;
}
```

我们可以直接这样写：

```java
Integer integer2= 100;
```

另外：

添加了一个注解，用于标识当前是是基于值的类，比如 Java 8 引入的预防空指针的 Optional 类，现在已经添加了注解标识。

```java
@jdk.internal.ValueBased
public final class Optional<T> {
    // ...
}
```

再举例：

```java
@jdk.internal.ValueBased
public final class SomeVbc {

    public SomeVbc() {}

    final String ref = "String";

    void abuseVbc() {

        synchronized(ref) {           // OK
            synchronized (this) {     // WARN
            }
        }
    }
}

final class AuxilliaryAbuseOfVbc {

    void abuseVbc(SomeVbc vbc) {

        synchronized(this) {           // OK
            synchronized (vbc) {       // WARN
            }
        }
    }
}
```

### 7.5 JDK16/17：Vector API

**JDK16的预览特性：**

提供了jdk.incubator.vector来用于矢量计算。

Vector API的想法是提供一种向量计算方法，最终实现比传统的标量计算方法（在支持 CPU 体系架构上）提供更高的性能。什么叫做向量计算呢？熟悉pandas的朋友可能知道，在pandas可以方便的对矩阵进行计算，如果用java实现则需要计算矩阵中的每个元素，非常麻烦，这也是python的pandas库能够流行的原因。

现在JDK16也可以做到了，我们一起来看看,先是传统写法：

```java
//传统写法
int[] x = {1, 2, 3, 4};
int[] y = {4, 3, 2, 1};
int[] c = new int[x.length];

for (int i = 0; i < x.length; i++) {
    c[i] =x[i] * y[i];
}
```

如果我们希望两个数组的数字相乘，则只能进行每个元素的遍历。

现在的写法：

```java
var vectorA = IntVector.fromArray(IntVector.SPECIES_128, x, 0);
var vectorB = IntVector.fromArray(IntVector.SPECIES_128, y, 0);
var vectorC = vectorA.mul(vectorB);
vectorC.intoArray(c, 0);
```

我们构建两个Vector变量，直接调用Vector类的mul方法即可。

fromArray中有三个参数，第一个是向量的长度，第二是原数组，第三个是偏移量。因为一个int有4个字节，所以这里我们使用SPECIES_128。

再举例：

```java
static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_256;

void vectorComputation(float[] a, float[] b, float[] c) {

    for (int i = 0; i < a.length; i += SPECIES.length()) {
        var m = SPECIES.indexInRange(i, a.length);
        // FloatVector va, vb, vc;
        var va = FloatVector.fromArray(SPECIES, a, i, m);
        var vb = FloatVector.fromArray(SPECIES, b, i, m);
        var vc = va.mul(va).
                    add(vb.mul(vb)).
                    neg();
        vc.intoArray(c, i, m);
    }
}
```

**JDK17中二次预览特性：**

Vector API 这是一个新的初始迭代孵化器模块，模块包：jdk.incubator.vector，用于表示在运行时可靠地编译到支持的 CPU 架构上的最佳矢量硬件指令的矢量计算，矢量运算可以提供优于等效标量计算的性能，并且在机器学习、人工智能和密码学等领域非常普遍。

本次增强的 API 允许以一种在运行时，可靠地编译为支持的 CPU 架构上的最佳向量指令的方式表达向量计算。

### 7.6 JDK17：标记删除Applet API

Applet API 提供了一种将 Java AWT/Swing 控件嵌入到浏览器网页中的方法。不过，目前 Applet 已经被淘汰。大部分人应该和我一样，压根就没有用过 Applet。

Applet API 实际上是无用的，因为所有 Web 浏览器供应商都已删除或透露计划放弃对 Java 浏览器插件的支持。Java 9 的时候，Applet API 已经被标记为启用，Java 17 的时候终于标记为删除了。

具体如下：

```java
java.applet.Applet
java.applet.AppletStub
java.applet.AppletContext
java.applet.AudioClip
javax.swing.JApplet
java.beans.AppletInitializer
```



## 8.  其它结构变化

### 8.1 JDK目录结构变化

这是JDK9的新特性。

JDK 8 的目录结构

![image-20220527204218066](images/image-20220527204218066.png)

| 目录          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| bin  目录     | 包含命令行开发和调试工具，如javac，jar和javadoc。            |
| include目录   | 包含在编译本地代码时使用的C/C++头文件                        |
| lib  目录     | 包含JDK工具的几个JAR和其他类型的文件。 它有一个tools.jar文件，其中包含javac编译器的Java类 |
| jre/bin  目录 | 包含基本命令，如java命令。 在Windows平台上，它包含系统的运行时动态链接库（DLL）。 |
| jre/lib  目录 | 包含用户可编辑的配置文件，如.properties和.policy文件。包含几个JAR。  rt.jar文件包含运行时的Java类和资源文件。 |

 JDK 9 的目录结构

![image-20220527204235793](images/image-20220527204235793.png)

| 目录         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| bin 目录     | 包含所有命令。 在Windows平台上，它继续包含系统的运行时动态链接库。 |
| conf 目录    | 包含用户可编辑的配置文件，例如以前位于jre\lib目录中的.properties和.policy文件 |
| include 目录 | 包含要在以前编译本地代码时使用的C/C++头文件。 它只存在于JDK中 |
| jmods 目录   | 包含JMOD格式的平台模块。 创建自定义运行时映像时需要它。 它只存在于JDK中 |
| legal 目录   | 包含法律声明                                                 |
| lib 目录     | 包含非Windows平台上的动态链接本地库。 其子目录和文件不应由开发人员直接编辑或使用 |

>   没有名为jre的子目录  

### 8.2 模块化系统: Jigsaw -> Modularity

这是JDK9的新特性。

- 谈到 Java 9 大家往往第一个想到的就是 Jigsaw 项目。众所周知，Java 已经发展超过 20 年（95 年最初发布），Java 和相关生态在不断丰富的同时也越来越暴露出一些问题：
  - Java 运行环境的膨胀和臃肿。每次JVM启动的时候，至少会有30～60MB的内存加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第一步整个jar都会被JVM加载到内存当中去（而模块化可以根据模块的需要加载程序运行需要的class）
  - 当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长。不同版本的类库交叉依赖导致让人头疼的问题，这些都阻碍了 Java 开发和运行效率的提升。
  - 很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共类所访问到，这样就会导致无意中使用了并不想被公开访问的 API。
  - 类路径本身也存在问题: 你怎么知晓所有需要的 JAR 都已经有了, 或者是不是会有重复的项呢?
- 同时，由于兼容性等各方面的掣肘，对 Java 进行大刀阔斧的革新越来越困难，Jigsaw 从 Java 7 阶段就开始筹备，Java 8 阶段进行了大量工作，终于在 Java 9 里落地，一种千呼万唤始出来的意味。


- Jigsaw项目（后期更名为Modularity）的工作量和难度大大超出了初始规划。JSR 376 Java 平台模块化系统（JPMS, Java Platform Module System）作为 Jigsaw 项目的核心, 其主体部分被分解成 6 个 JEP(JDK Enhancement Proposals)。


- 作为java 9 平台最大的一个特性，随着 Java 平台模块化系统的落地，开发人员无需再为不断膨胀的 Java 平台苦恼，例如，您可以使用 jlink 工具，根据需要定制运行时环境。这对于拥有大量镜像的容器应用场景或复杂依赖关系的大型应用等，都具有非常重要的意义。


- 本质上讲，模块(module)的概念，其实就是package外再裹一层，也就是说，用模块来管理各个package，通过声明某个package暴露，不声明默认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪些部分可以暴露，哪些部分隐藏。

**实现目标**

- 主要目的在于减少内存的开销

- 只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开发和维护

- 改进 Java SE 平台，使其可以适应不同大小的计算设备

- 改进其安全性，可维护性，提高性能

举例：略

### 8.3 其它语法变化

#### 8.3.1 JDK9语法改进：UnderScore(下划线)使用的限制

在java 8 中，标识符可以独立使用“_”来命名：

```java
String _ = "hello";
System.out.println(_);
```

但是，在java 9 中规定“_”不再可以单独命名标识符了，如果使用，会报错：

![image-20220527233322495](images/image-20220527233322495.png)



#### 8.3.2 JDK9/17：AOT

**JDK9中：**

**产生背景**

Oracle 一直在努力提高 Java 启动和运行时性能，希望其能够在更广泛的场景达到或接近本地语言的性能。但是，直到今天，谈到 Java，很多 C/C++ 开发者还是会不屑地评价为启动慢，吃内存。

简单说，这主要是因为 Java 编译产生的类文件是 Java 虚拟机可以理解的二进制代码，而不是真正的可执行的本地代码，需要 Java 虚拟机进行解释和编译，这带来了额外的开销。

**使用说明**

JIT（Just-in-time）编译器可以在运行时将热点编译成本地代码，速度很快。但是 Java 项目现在变得很大很复杂，因此 JIT 编译器需要花费较长时间才能热身完，而且有些 Java 方法还没法编译，性能方面也会下降。AoT 编译就是为了解决这些问题而生的。

在 JDK 9 中， AOT（JEP 295: Ahead-of-Time Compilation）作为实验特性被引入进来，开发者可以利用新的 jaotc 工具将重点代码转换成类似类库一样的文件。虽然仍处于试验阶段，但这个功能使得 Java 应用在被虚拟机启动之前能够先将 Java 类编译为原生代码。此功能旨在改进小型和大型应用程序的启动时间，同时对峰值性能的影响很小。 

但是 Java 技术供应商 Excelsior 的营销总监 Dmitry Leskov 担心 AoT 编译技术不够成熟，希望 Oracle 能够等到 Java 10 时有个更稳定版本才发布。

**JDK17中：**

删除实验性的基于 Java 的提前 (AOT) ，因为使用有限，维护它所需的工作量很重要。

作为实验性功能，JDK 9 已与提前编译（jaotc 工具）集成。对于 AOT 编译，jaotc 使用 Java 编写的 Graal 编译器。由于这些实验特性尚未使用，因此需要付出相当大的努力来维护和改进它们。Oracle 发布的 JDK 16 版本没有这些功能，也没有人抱怨。

#### 8.3.3 JDK11：更简化的编译运行程序

看下面的代码。

```java
// 编译
javac Javastack.java

// 运行
java Javastack
```

在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。而在 Java 11 版本中，通过一个 java 命令就直接搞定了，如以下所示：

```
java Javastack.java
```

一个命令编译运行源代码的注意点：

- 执行源文件中的第一个类, 第一个类必须包含主方法。

- 并且不可以使用其它源文件中的自定义类, 本文件中的自定义类是可以使用的。

#### 8.3.4 JDK14：有用的NullPointerExceptions

Helpful NullPointerExceptions可以在我们遇到NPE时节省一些分析时间。如下的代码会导致一个NPE。

```java
public static void main(String[] args) {
    Person p = new Person();
	String cityName = p.getAddress().getCity().getName();
}
```

在Java 11中，输出将显示NullPointerException发生的行号，但不知道哪个方法调用时产生的null，必须通过调试的方式找到。

```java
Exception in thread "main" java.lang.NullPointerException
        at com.atguigu.java.Demo.main(HelpfulNullPointerExceptionsDemo.java:13)
```

在Java 17中，则会准确显示发生NPE的精确位置。

```java
Exception in thread "main" java.lang.NullPointerException: Cannot invoke "com.heiz.java17.Address.getCity()" because the return value of "com.heiz.java17.Person.getAddress()" is null
		at com.atguigu.java.Demo.main(HelpfulNullPointerExceptionsDemo.java:13)
```

#### 8.3.5 JDK16：弹性元空间

Metaspace 的主要功能是管理类的元数据的内存。引入 Elastic Metaspace 是为了改进 HotSpot JVM 中元空间内存的分配和释放。可以更快地将不需要的内存返回给操作系统，从而减少开销和内存碎片。

Elastic Metaspace使用较小的块分配内存，并通过将未使用的元空间内存返回给操作系统来提高弹性。它可以提高性能并降低维护成本。

#### 8.3.6 JDK17：JDK内部元素强封装

很多程序员以损害安全性和可维护性的方式使用 JDK 的内部元素比如一些非`public`类、方法和字段。

为了继续提高 JDK 的安全性和可维护性，默认强封装 JDK 的所有内部元素，从而限制对它们的访问，除了关键的内部 API 如`sun.misc.Unsafe`。鼓励开发人员从内部元素迁移到标准 API。

此外，用户仍然可以选择自 JDK 9 以来的默认的宽松的强封装，这样可以帮助用户毫不费力地升级到未来的 Java 版本。

## 9. GC方面新特性

GC是java主要优势之一。 然而, 当GC停顿太长, 就会开始影响应用的响应时间。消除或者减少GC停顿时长, java将对更广泛的应用场景是一个更有吸引力的平台。此外, 现代系统中可用内存不断增长,用户和程序员希望JVM能够以高效的方式充分利用这些内存, 并且无需长时间的GC暂停时间。

### JDK10 : 为G1提供并行的Full GC

这个JEP的目标只有一个，那就是要把G1的full GC算法给并行化，从而提高性能。你知道，G1最大的亮点就是可以尽量的避免full gc。但毕竟是“尽量”，在有些情况下，G1就要进行full gc了，比如如果它无法足够 快的 回收内存的时候，它就会强制停止所有的应用 线程 然后清理。在Java10之前，一个单线程版的标记-清除-压缩算法被用于full gc。

所以为了尽量减少full gc带来的影响，在Java10中，就把之前的那个单线程版的标记-清除-压缩的full gc算法改成了支持多个线程同时full gc。这样也算是减少了full gc所带来的停顿。

你可以通过-XX:ParallelGCThreads这个 参数 来指定用于并行GC的线程数。



### JDK11：引入的 ZGC

ZGC, 这应该是JDK11最为瞩目的特性, 没有之一。 

ZGC是一个并发, 基于region, 压缩型的垃圾收集器, 只有root扫描阶段会STW(stop the world), 因此GC停顿时间不会随着堆的增长和存活对象的增长而变长。

ZGC的设计目标是：支持TB级内存容量，暂停时间低（<10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。

### JDK11：引入的 Epsilon GC

JDK上对这个特性的描述是: 开发一个处理内存分配但不实现任何实际内存回收机制的GC, 一旦可用堆内存用完, JVM就会退出.

如果有System.gc()调用, 实际上什么也不会发生(这种场景下和`-XX:+DisableExplicitGC`效果一样), 因为没有内存回收, 这个实现可能会警告用户尝试强制GC是徒劳.

用法 : `-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC`

如果使用选项-XX:+UseEpsilonGC, 程序很快就因为堆空间不足而退出。使用这个选项的原因 :

提供完全被动的GC实现, 具有有限的分配限制和尽可能低的延迟开销,但代价是内存占用和内存吞吐量。

这个垃圾收集器实际上不做任何工作，因此允许您精确测量应用程序的内存使用情况。如果您想保持尽可能低的内存操作吞吐量，则很有用。主要用途如下 :

- 性能测试(它可以帮助过滤掉GC引起的性能假象)

- 内存压力测试(例如,知道测试用例 应该分配不超过1GB的内存, 我们可以使用-Xmx1g –XX:+UseEpsilonGC, 如果程序有问题, 则程序会崩溃)
- 非常短的JOB任务(对象这种任务, 接受GC清理堆那都是浪费空间)
- VM接口测试

- Last-drop 延迟&吞吐改进

### JDK12：Shenandoah GC：低停顿时间的GC

![image-20220528212254705](images/image-20220528212254705.png)

6.2.1背景和设计思路

Shenandoah 垃圾回收器是 Red Hat 在 2014 年宣布进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在**针对 JVM 上的内存收回实现低停顿的需求**。该设计将与应用程序线程并发，通过交换 CPU 并发周期和空间以改善停顿时间，使得垃圾回收器执行线程能够在 Java 线程运行时进行堆压缩，并且标记和整理能够同时进行，因此避免了在大多数 JVM 垃圾收集器中所遇到的问题。

据 Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200 MB 还是 200 GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。

与其他 Pauseless GC 类似，**Shenandoah GC 主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等。**

这是一个实验性功能，不包含在默认（Oracle）的OpenJDK版本中。

6.2.5 工作原理

从原理的角度，我们可以参考该项目官方的示意图，其内存结构与 G1 非常相似，都是将内存划分为类似棋盘的 region。整体流程与 G1 也是比较相似的，**最大的区别在于实现了并发的 疏散(Evacuation) 环节，引入的 Brooks Forwarding Pointer 技术使得 GC 在移动对象时，对象引用仍然可以访问。**

Shenandoah GC 工作周期如下所示：

![img](images/8c7e82c8bebe0305a927a1d39e66f2f7.jpeg)

```
上图对应工作周期如下：
1. Init Mark 启动并发标记 阶段
2. 并发标记遍历堆阶段
3. 并发标记完成阶段
4. 并发整理回收无活动区域阶段
5. 并发 Evacuation 整理内存区域阶段
6. Init Update Refs 更新引用初始化 阶段
7. 并发更新引用阶段
8. Final Update Refs 完成引用更新阶段
9. 并发回收无引用区域阶段
```

6.2.6 信息延展

不是唯有 GC 停顿可能导致常规应用程序响应时间比较长。具有较长的 GC 停顿时间会导致系统响应慢的问题，但响应时间慢并非一定是 GC 停顿时间长导致的，队列延迟、网络延迟、其他依赖服务延迟和操作提供调度程序抖动等都可能导致响应变慢。使用 Shenandoah 时需要全面了解系统运行情况，综合分析系统响应时间。下面是 jbb15 benchmark 中，Shenandoah GC 相对于其他主流 GC 的表现。

各种 GC 工作负载对比：

![img](images/c04f4bbc49b74088a5024b9ff98878eb.jpeg)

GC 暂停相比于 CMS 等选择有数量级程度的提高，对于 GC 暂停非常敏感的场景，价值还是很明显的，能够在 SLA 层面有显著提高。当然，这种对于低延迟的保证，也是以消耗 CPU 等计算资源为代价的，实际吞吐量表现也不是非常明朗，需要看企业的实际场景需求，并不是一个一劳永逸的解决方案。

Shenandoah开发团队在实际应用中的测试数据：

![image-20220528212323729](images/image-20220528212323729.png)

### JDK12：可中断的 G1 Mixed GC

简言之，当 G1 垃圾回收器的回收超过暂停时间的目标，则能中止垃圾回收过程。

G1是一个垃圾收集器，设计用于具有大量内存的多处理器机器。由于它提高了性能效率，G1垃圾收集器最终将取代CMS垃圾收集器。

**该垃圾收集器设计的主要目标之一是满足用户设置的预期的 JVM 停顿时间。**

G1 采用一个高级分析引擎来选择在收集期间要处理的工作量，此选择过程的结果是一组称为 GC 回收集（collection set(`CSet`)）的区域。一旦收集器确定了 GC 回收集 并且 GC 回收、整理工作已经开始，这个过程是without stopping的，即 G1 收集器必须完成收集集合的所有区域中的所有活动对象之后才能停止；但是如果收集器选择过大的 GC 回收集，此时的STW时间会过长超出目标pause time。

这种情况在mixed collections时候比较明显。这个特性启动了一个机制，当选择了一个比较大的collection set，Java 12 中将把 GC 回收集（混合收集集合）拆分为mandatory（必需或强制）及optional两部分(`当完成mandatory的部分，如果还有剩余时间则会去处理optional部分`)来将mixed collections从without stopping变为abortable，以更好满足指定pause time的目标。

- 其中必需处理的部分包括 G1 垃圾收集器不能递增处理的 GC 回收集的部分（如：年轻代），同时也可以包含老年代以提高处理效率。

- 将 GC 回收集拆分为必需和可选部分时，垃圾收集过程优先处理必需部分。同时，需要为可选 GC 回收集部分维护一些其他数据，这会产生轻微的 CPU 开销，但小于 1 ％的变化，同时在 G1 回收器处理 GC 回收集期间，本机内存使用率也可能会增加，使用上述情况只适用于包含可选 GC 回收部分的 GC 混合回收集合。

- 在 G1 垃圾回收器完成收集需要必需回收的部分之后，如果还有时间的话，便开始收集可选的部分。但是粗粒度的处理，可选部分的处理粒度取决于剩余的时间，一次只能处理可选部分的一个子集区域。在完成可选收集部分的收集后，G1 垃圾回收器可以根据剩余时间决定是否停止收集。如果在处理完必需处理的部分后，剩余时间不足，总时间花销接近预期时间，G1 垃圾回收器也可以中止可选部分的回收以达到满足预期停顿时间的目标。

### JDK12：增强G1，自动返回未用堆内存给操作系统

6.8.1 概述

上面介绍了 Java 12 中增强了 G1 垃圾收集器关于混合收集集合的处理策略，这节主要介绍在 Java 12 中同时也对 G1 垃圾回收器进行了改进，使其能够在空闲时自动将 Java 堆内存返还给操作系统，这也是 Java 12 中的另外一项重大改进。

目前 Java 11 版本中包含的 G1 垃圾收集器暂时无法及时将已提交的 Java 堆内存返回给操作系统。为什么呢？ G1目前只有在full GC或者concurrent cycle（并发处理周期）的时候才会归还内存，由于这两个场景都是G1极力避免的，因此在大多数场景下可能不会及时归还committed Java heap memory给操作系统。除非有外部强制执行。

在使用云平台的容器环境中，这种不利之处特别明显。即使在虚拟机不活动，但如果仍然使用其分配的内存资源，哪怕是其中的一小部分，G1 回收器也仍将保留所有已分配的 Java 堆内存。而这将导致用户需要始终为所有资源付费，哪怕是实际并未用到，而云提供商也无法充分利用其硬件。如果在此期间虚拟机能够检测到 Java 堆内存的实际使用情况，并在利用空闲时间自动将 Java 堆内存返还，则两者都将受益。

6.8.2 具体操作

为了尽可能的向操作系统返回空闲内存，G1 垃圾收集器将在应用程序不活动期间定期生成或持续循环检查整体 Java 堆使用情况，以便 G1 垃圾收集器能够更及时的将 Java 堆中不使用内存部分返还给操作系统。对于长时间处于空闲状态的应用程序，此项改进将使 JVM 的内存利用率更加高效。

而在用户控制下，可以可选地执行Full GC，以使返回的内存量最大化。

JDK12的这个特性新增了两个参数分别是G1 PeriodicGCInterval及G1 PeriodicGCSystemLoadThreshold，设置为0的话，表示禁用。如果应用程序为非活动状态，在下面两种情况任何一个描述下，G1 回收器会触发定期垃圾收集：

- 自上次垃圾回收完成以来已超过 G1PeriodicGCInterval (`milliseconds`)， 并且此时没有正在进行的垃圾回收任务。如果 G1PeriodicGCInterval 值为零表示禁用快速回收内存的定期垃圾收集。


- 应用所在主机系统上执行方法 getloadavg()，默认一分钟内系统返回的平均负载值低于 G1PeriodicGCSystemLoadThreshold指定的阈值，则触发full GC或者concurrent GC(`如果开启G1PeriodicGCInvokesConcurrent`)，GC之后Java heap size会被重写调整，然后多余的内存将会归还给操作系统。如果 G1PeriodicGCSystemLoadThreshold 值为零，则此条件不生效。


如果不满足上述条件中的任何一个，则取消当期的定期垃圾回收。等一个 G1PeriodicGCInterval 时间周期后，将重新考虑是否执行定期垃圾回收。

G1 定期垃圾收集的类型根据 G1PeriodicGCInvokesConcurrent 参数的值确定：如果设置值了，G1 垃圾回收器将继续上一个或者启动一个新并发周期；如果没有设置值，则 G1 回收器将执行一个Full GC。在每次一次 GC 回收末尾，G1 回收器将调整当前的 Java 堆大小，此时便有可能会将未使用内存返还给操作系统。新的 Java 堆内存大小根据现有配置确定，具体包括下列配置：- XX:MinHeapFreeRatio、-XX:MaxHeapFreeRatio、-Xms、-Xmx。

默认情况下，G1 回收器在定期垃圾回收期间新启动或继续上一轮并发周期，将最大限度地减少应用程序的中断。如果定期垃圾收集严重影响程序执行，则需要考虑整个系统 CPU 负载，或让用户禁用定期垃圾收集。

### JDK13：ZGC:取消使用未使用的内存

在JDK 11中，Java引入了ZGC，这是一款可伸缩的低延迟垃圾收集器，但是当时只是实验性的。号称不管你开了多大的堆内存，它都能保证在 10 毫秒内释放 JVM ，不让它停顿在那。但是，当时的设计是它不能把内存归还给操作系统。对于比较关心内存占用的应用来说，肯定希望进程不要占用过多的内存空间了，所以这次增加了这个特性。

![1568796248165](images/1568796248165.png)

在Java 13中，JEP 351再次对ZGC做了增强，将没有使用的堆内存归还给操作系统。ZGC当前不能把内存归还给操作系统，即使是那些很久都没有使用的内存，也只进不出。这种行为并不是对任何应用和环境都是友好的，尤其是那些内存占用敏感的服务，例如：

1. 按需付费使用的容器环境；
2. 应用程序可能长时间闲置，并且和很多其他应用共享和竞争资源的环境；
3. 应用程序在执行期间有非常不同的堆空间需求，例如，可能在启动的时候所需的堆比稳定运行的时候需要更多的堆内存。

**7.4.3 使用细节**

ZGC的堆由若干个Region组成，每个Region被称之为**ZPage**。每个Zpage与数量可变的已提交内存相关联。当ZGC压缩堆的时候，ZPage就会释放，然后进入page cache，即**ZPageCache**。这些在page cache中的ZPage集合就表示没有使用部分的堆，这部分内存**应该**被归还给操作系统。回收内存可以简单的通过从page cache中逐出若干个选好的ZPage来实现，由于page cache是以LRU（Least recently used，最近最少使用）顺序保存ZPage的，并且按照尺寸（小，中，大）进行隔离，因此逐出ZPage机制和回收内存相对简单了很多，**主要挑战是设计关于何时从page cache中逐出ZPage的策略。**

一个简单的策略就是设定一个超时或者延迟值，表示ZPage被驱逐前，能在page cache中驻留多长时间。这个超时时间会有一个合理的默认值，也可以通过JVM参数覆盖它。Shenandoah GC用了一个类型的策略，默认超时时间是5分钟，可以通过参数-**XX:ShenandoahUncommitDelay = milliseconds**覆盖默认值。

像上面这样的策略可能会运作得相当好。但是，用户还可以设想更复杂的策略：**不需要添加任何新的命令行选项。**例如，基于GC频率或某些其他数据找到合适超时值的启发式算法。**JDK13将使用哪种具体策略目前尚未确定。**可能最初只提供一个简单的超时策略，使用**-XX:ZUncommitDelay = seconds**选项，以后的版本会添加更复杂、更智能的策略（如果可以的话）。

uncommit能力默认是开启的，但是无论指定何种策略，ZGC都不能把堆内存降到低于Xms。这就意味着，如果Xmx和Xms相等的话，这个能力就失效了。-XX:-ZUncommit这个参数也能让这个内存管理能力失效。

### JDK14：弃用ParallelScavenge和SerialOld GC组合

![image-20220528212048244](images/image-20220528212048244.png)

- 由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214）

- ParallelScavenge + SerialOld GC的GC组合要被标记为Deprecate了。

- JDK官方给出将这个GC组合标记为Deprecate的理由是：这个GC组合需要大量的代码维护工作，并且，这个GC组合很少被使用。因为它的使用场景应该是一个很大的Young区配合一个很小的Old区，这样的话，Old区用SerialOldGC去收集时停顿时间我们才能勉强接受。

- 废弃了parallel young generation GC与SerialOld GC的组合( -XX:+UseParallelGC与-XX:-UseParallelOldGC配合开启)，现在使用-XX:+UseParallelGC -XX:-UseParallelOldGC或者-XX:-UseParallelOldGC都会出现告警如下：

![image-20220528212116767](images/image-20220528212116767.png)

### JDK14：删除CMS垃圾回收器

- 该来的总会来，自从G1（基于Region分代）横空出世后，CMS在JDK9中就被标记为Deprecate了（JEP 291: Deprecate the Concurrent Mark Sweep (CMS) Garbage Collector）

- CMS的弊端 ：

  1.会产生内存碎片，导致并发清除后，用户线程可用的空间不足。

  2.既然强调了并发（Concurrent），CMS收集器对CPU资源非常敏感

  3.CMS 收集器无法处理浮动垃圾

- 上述的这些问题，尤其是碎片化问题，给你的JVM实例就像埋了一颗炸弹。说不定哪次就在你的业务高峰期来一次FGC。当CMS停止工作时，会把Serial Old GC 作为备选方案，而Serial Old GC 是JVM中性能最差的垃圾回收方式，停顿个几秒钟，上十秒都有可能。

- 移除了CMS垃圾收集器，如果在JDK14中使用-XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息。

### JDK14：ZGC on macOS和windows

- JDK14之前，ZGC仅Linux才支持。现在mac或Windows上也能使用ZGC了，示例如下：

  ```
  -XX:+UnlockExperimentalVMOptions -XX:+UseZGC
  ```

- ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。

- 《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。

![image-20220528212414676](images/image-20220528212414676.png)

![image-20220528212421319](images/image-20220528212421319.png)

> 虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。
>
> 未来将在服务端、大内存、低延迟应用的首选垃圾收集器。

### JDK15：ZGC 功能转正

ZGC是Java 11引入的新的垃圾收集器（JDK9以后默认的垃圾回收器是G1），经过了多个实验阶段，自此终于成为正式特性。

自 2018 年以来，ZGC 已增加了许多改进，从并发类卸载、取消使用未使用的内存、对类数据共享的支持到改进的 NUMA 感知。此外，最大堆大小从 4 TB 增加到 16 TB。支持的平台包括 Linux、Windows 和 MacOS。

ZGC是一个重新设计的并发的垃圾回收器，通过减少 GC 停顿时间来提高性能。

但是这并不是替换默认的GC，默认的GC仍然还是G1；之前需要通过`-XX:+UnlockExperimentalVMOptions`、` -XX:+UseZGC`来启用ZGC，现在只需要`-XX:+UseZGC`就可以。相信不久的将来它必将成为默认的垃圾回收器。

相关的参数有ZAllocationSpikeTolerance、ZCollectionInterval、ZFragmentationLimit、ZMarkStackSpaceLimit、ZProactive、ZUncommit、ZUncommitDelay ZGC-specific JFR events(ZAllocationStall、ZPageAllocation、ZPageCacheFlush、ZRelocationSet、ZRelocationSetGroup、ZUncommit)也从experimental变为product

### JDK15：Shenandoah垃圾回收算法转正

Shenandoah垃圾回收算法终于从实验特性转变为产品特性，这是一个从 JDK 12 引入的回收算法，该算法通过与正在运行的 Java 线程同时进行疏散工作来减少 GC 暂停时间。Shenandoah 的暂停时间与堆大小无关，无论堆栈是 200 MB 还是 200 GB，都具有相同的一致暂停时间。

怎么形容Shenandoah和ZGC的关系呢？异同点大概如下：

- 相同点：性能几乎可认为是相同的
- 不同点：ZGC是Oracle JDK的，根正苗红。而Shenandoah只存在于OpenJDK中，因此使用时需注意你的JDK版本

打开方式：使用-XX:+UseShenandoahGC命令行参数打开。


Shenandoah在JDK12被作为experimental引入，在JDK15变为Production；之前需要通过-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC来启用，现在只需要-XX:+UseShenandoahGC即可启用

### JDK16：ZGC 并发线程处理

我们知道ZGC是HotSpot JVM中一种低延时的垃圾回收算法。但是在线程的堆栈处理过程中，总有一个制约因素就是safepoints。在safepoints这个点，java的线程是要暂停执行的，从而限制了GC的效率。

> 回顾：
>
> 我们都知道，在之前，需要 GC 的时候，为了进行垃圾回收，需要所有的线程都暂停下来，这个暂停的时间我们成为 **Stop The World**。
>
> 而为了实现 STW 这个操作， JVM 需要为每个线程选择一个点停止运行，这个点就叫做**安全点（Safepoints）**。

而ZGC的并发线程堆栈处理可以保证java线程可以在GC safepoints的同时可以并发执行。它有助于提高所开发的java软件应用程序的性能和效率。

## 10. GraalVM

在JDK11中将运行JS应用Nashorn引擎标记为过时，并在JDK15中删除了Nashorn JavaScript Engine及jjs 命令行工具。

在JDK11中取以代之的是GraalVM。GraalVM是一个运行时平台，它支持Java和其他基于Java字节码的语言，但也支持其他语言，如JavaScript，Ruby，Python或LLVM。性能是Nashorn的2倍以上。

在JDK17中，移除实验性的java版本的AOT及JIT Compiler，具体移除：

```java
jdk.aot — the jaotc tool
jdk.internal.vm.compiler — the Graal compiler
jdk.internal.vm.compiler.management — Graal's MBean
```

后续要使用可以使用 Graal 编译器 ( [GraalVM](https://www.graalvm.org/) )进行 JIT 编译。

![image-20220529003920290](images/image-20220529003920290.png)

Graal VM在HotSpot VM基础上增强而成的`跨语言全栈虚拟机`，可以作为“`任何语言`”的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、JavaScript、Ruby、Python、R等

## 11. 小结与展望

随着云计算和 AI 等技术浪潮，当前的计算模式和场景正在发生翻天覆地的变化，不仅对 Java 的发展速度提出了更高要求，也深刻影响着 Java 技术的发展方向。**传统的大型企业或互联网应用，正在被云端、容器化应用、模块化的微服务甚至是函数(FaaS， Function-as-a-Service)所替代。**

Java虽然标榜面向对象编程，却毫不顾忌的加入`面向接口编程思想`，又扯出`匿名对象`之概念，每增加一个新的东西，对Java的根本所在的面向对象思想的一次冲击。反观Python，抓住面向对象的本质，又能在函数编程思想方面游刃有余。**Java对标C/C++，以抛掉内存管理为卖点，却又陷入了JVM优化的噩梦。**选择比努力更重要，选择Java的人更需要对它有更清晰的认识。

**Java 需要在新的计算场景下，改进开发效率。**这话说的有点笼统，我谈一些自己的体会，Java 代码虽然进行了一些类型推断等改进，更易用的集合 API 等，但仍然给开发者留下了过于刻板、形式主义的印象，这是一个长期的改进方向。

